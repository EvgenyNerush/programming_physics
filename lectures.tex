%\documentclass{revtex4-1}
\documentclass{book}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc} % Выбор языка и кодировки
\usepackage[english,russian]{babel}
\usepackage{minted}
%\usepackage{listings}
%\usepackage[cmap]
\usepackage[pdftex]{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
%%\usepackage{upgreek}
%%\usepackage{siunitx}

\graphicspath{{./figures/}}

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  allcolors=blue
}

%\lstset{language=Haskell}

\begin{document}

\title{Программирование для физиков}

\date{\today}
\author{Е. Н. Неруш}
%\email{nerush@appl.sci-nnov.ru}
%\affiliation{ИПФ РАН}
%\affiliation{ННГУ}

%\begin{abstract}
%C$++$
%\end{abstract}

\maketitle

\tableofcontents

\section{Введение}

В настоящее время почти ни одна статья по физике не обходится без компьютерного моделирования. В
сравнительно простых задачах оно позволяет выявить ошибки в аналитических моделях (хотя бы часть!).
В сложных задачах компьютерное моделирование позволяет <<заглянуть>> в области, недоступные в
настоящее время для эксперимента, например, узнать, что будет происходить с веществом в поле
магнетаров, по напряжённости намного большем доступного в настоящее время в лабораториях лазерного
поля. Часто эксперимент сам по себе настолько сложен, что требует компьютерной обработки
полученных данных (например, LIGO,  Event Horizon Telescope, эксперименты CERN). Однако стоит
помнить, что моделирование всегда основано на уже заложенных в него человеком некоторых базовых
законах, то есть не может существовать в отрыве от теоретических знаний.

Помимо базовых вопросов программирования, численных методов, структур данных и алгоритмов мы будем
здесь касаться вопросов проектирования качественного кода, а также вопросов, связанных с так
называемым <<метапрограммированием>>. Часто можно услышать, что ни то, ни другое не нужно. Однако
из-за того, что компьютерное моделирование прочно вошло в физику, обострилась проблема
воспроизводимости результатов. Код, содержащий ошибки, легко может привести к новым <<открытиям>>,
которые не имеют отношения к физической реальности. Код, написанный плохо, никто не сможет
проверить. Можно ли доверять результатам, полученным с его помощью? Что делать, если у двух разных
научных групп есть две программы для моделирования одной и той же задачи, которые дают разные
результаты? Решением (пусть и частичным) всех этих проблем видится публикация кода (как правило,
под открытой лицензией MIT или BSD) вместе со статьями, описывающими полученные результаты.

Метапрограммирование (в частности, использование шаблонов в C++) позволяет повысить качество кода и
возможности его проверки, уменьшить количество ошибок. Но, возможно, важнее даже то, как
метапрограммирование перестраивает мышление человека. Прежде всего, оно учит абстрактному мышлению,
учит отбрасывать всё лишнее, что само по себе является немаловажным умением не только для
программиста, но и для физика.

Несмотря на большие возможности компьютерного моделирования, стоит помнить, что оно ни в коем
случае не может заменить науку полностью. Цель науки --- не просто научиться воспроизводить
результаты эксперимента, цель - построение картины окружающего мира, который, что само по себе
удивительно, --- познаваем. Мы всегда можем выделить основные эффекты в любом, даже сложном,
явлении, можем <<уложить их в голову>> или описать <<на пальцах>>, и построить простые
аналитические модели, обладающие предсказательной силой. И это прекрасно.

Здесь я хотел бы привести пару ссылок. Во-первых,  \href{https://github.com/EvgenyNerush}{в моём
профиле на Github} можно найти примеры научного кода. Во-вторых,
\href{https://habr.com/ru/users/271828/posts/}{в моём профиле на Хабре} можно найти статьи,
перекликающиеся с темами этих лекций.

\section{Историческая справка}

Сегодня компьютеры используют, например, для проектирования зданий (с 70-x 80-x годов), управления самолётами и
автомобилями, для игры в шахматы и т. д. Как решали раньше задачи, которые требуют огромного
количества вычислений сегодня? Предположим, что нам нужно построить кирпичную арку. Сегодня мы
можем нарисовать что угодно на компьютере и смоделировать напряжения материала. Соответственно, мы
можем подобрать форму так, чтобы напряжения были минамальны и арка не разрушилась бы. Другой способ
--- построить теорию арки, вычислить её форму аналитически. Третий способ --- физическое
моделирование (аналоговые вычисления). Можно заметить, что на каждый кусочек веревки, подвешенной
за два конца, силы действуют только по касательной. Этого же мы хотим добиться, если складываем
арку из кирпича. Таким образом, можно использовать форму веревки для конструирования арки.

\begin{figure}
	\includegraphics[width=1\linewidth]{arches.png}
    \caption{Слева направо: Венский Университет Экономики и Бизнеса (библиотека и учебный центр,
    2013, Заха Хадид, фотография Böhringer Friedrich), свод храма Святого Семейства, Барселона
    (1882, Антонио Гауди) и одна из веревочных моделей Гауди.}
\end{figure}
\begin{figure}
	\includegraphics[width=1\linewidth]{sliderule.png}
    \caption{Логарифмическая линейка. Показано умножение чисел $1.3$ (шкала D) на $2$ (шкала C),
    ответ --- на шкале D, $2.6$.}
\end{figure}

Родилась вычислительная техника из общей проблемы проведения сложных вычислений.
Сначала использовали таблицы (с вычисленными вручную значениями) и аппроксимацию, позже, в XVII
веке, изобрели логарифмическую линейку. Идея:
\begin{eqnarray}
    \log(xy) = \log x + \log y,\\
    \log(x / y) = \log(x) - \log(y).
\end{eqnarray}

Арифмометры --- механические вычислительные машины для точного сложения и других операций появились
приблизительно в то же время. Первой ласточкой была машина Паскаля (19 летний Блез хотел помочь
своему отцу, сборщику налогов, с его расчётами; 1642 год), в 1673 году Лейбниц, мотивированный
астрономическими вычислениями, создал свой арифмометр. С тех пор арифмометры широко
распространились и выпускались до 70-х 80-х годов двадцатого века.

Более универсальной, по сравнению с простыми арифмометрами, была разностная машина Чарльза Бэббиджа
(начало XIX века), предназначенная для для вычисления многочленов и разностной аппроксимации,
которая, как и большинство арифмометров, использовала десятичную систему счисления. В
ходе работы у Бэббиджа возникла идея создания универсальной вычислительной машины, которую он
назвал аналитической и которая стала прообразом современного цифрового компьютера. В единую
логическую схему Бэббидж увязал арифметическое устройство, регистры
памяти, и устройство ввода-вывода, реализованное с помощью
перфокарт трёх типов. Перфокарты операций переключали машину между режимами сложения, вычитания,
деления и умножения. Перфокарты переменных управляли передачей данных из памяти в арифметическое
устройство и обратно. Числовые перфокарты могли быть использованы как для ввода данных в машину,
так и для сохранения результатов вычислений, если памяти было недостаточно. Ни разностная, ни
аналитическая машины не были построены, однако первая компьютерная программа была написана именно
для разностной машины Бэббиджа (вычисление чисел Бернулли, 1843 год, Ада Лавлейс). Программа, по
сути, была написана на ассемблере --- она описывала, какимы входными значениями должны быть
заполнены "регистры", какие операции (низкоуровневые --- умножение, сложение, деление) и между
какими регистрами нужно производить. В программе были циклы и в целом она содержала 25 строк, но
работа Ады над ней заняла около года --- на самом деле программа довольно непростая.

qwe
Двоичная система - проще делать устройства. Задачки на перевод. Шестнадцатеричная система.

Конрад Цузе: Z1 (механическая программируемая, 1938 г.), Z3 (на реле, также
программируемая, вычисление корня) --- для чисел с плавающей запятой
(использовалось двоичное представление, не было условных переходов и циклов) ---
май 1941 г., Германия. Расчёты для управляемых ракет, аэродинамика. Z4,
Планкалкюль (подпрограммы, циклы, массивы).

Задача. Логика на реле. Вычисление суммы на реле.

ENIAC, 1943, таблицы стрельбы. Реле (нарисовать устройство), электронные лампы.

Энигма --- портативная шифровальная (и дешифровальная) машина, с начала 1930-х
годов. Шифр замены, провода, диски и лампочки с буквами.

Лоренц, шифр Вернама. Ключ XOR текст даст шифротекст, который может быть
расшифрован при знании ключа. Взлом в 1942 г. из за грубой ошибки оператора.

M-100 Спектр. Довольно большая машина, 140 кг. Суммирование с псевдослучайными
числами на конечном поле. По-видимому, не была взломана.

Turing Bombe, Великобритания, 1940 г. Одна машина эмулировала одновременно
несколько десятков Энигм, перебор ключа при известной открытой части, и Энигма
не шифровала букву саму в себя. Блетчли--Парк, 210 машин, 3 тысячи сообщений
ежедневно.

Проблема разрешения (Гильберт): найти алгоритм, который бы выдавал для
некоторого формального языка и утверждения на нём, истинно или ложно это
утверждение. 1936 г., независимо Алонзо Чёрч и Алан Тьюринг показали
неразрешимость данной проблемы для арифметики, и, следовательно, более общая
проблема неразрешима. Тьюринг для доказательства ввёл понятие машины (Тьюринга). 

Машина Тьюринга способна имитировать любой исполнитель, каким-либо образом
реализующий процесс пошагового вычисления. В её состав входит неограниченная в
обе стороны лента, разделённая на ячейки, и управляющее устройство, способное
находиться в конечном числе состояний. В ячейки на ленте записаны символы
конечного алфавита, либо пустые, либо терминальные (конец работы) символы.
Управляющее устройство работает по правилам перехода, предписывающим в
зависимости от символа в текущей клетке записать в неё новый символ, перейти в
другое состояние или перейти по ленте вправо или влево. Программировать для
такой машины очень сложно.

Вычислимая функция --- функция, которая может быть реализована на машине
Тьюринга. Например, XOR на поле 0, 1. Пусть головка изначально в состоянии 0 и
находится над первым числом, и прописаны следующие правила. 0: 1 - w1r, 0 - w0r.
1: 0 - w1r, 1 - w0r. Машина будет вычислять xor всей последовательности чисел, и
записывать результат, пока не дойдёт до терминального символа. Пример
невычислимой функции --- проблема Гильберта. Проблема останова --- невычислимая функция.

Другой пример вычислимой функции
--- функция Аккермана:
\begin{eqnarray}
    A(m, n) = n + 1, \; m = 0,\\
    A(m - 1, 1), \; m > 0, \; n = 0,\\
    A(m - 1, A(m, n - 1)), \; m > 0, \; n > 0.
\end{eqnarray}
\begin{equation}
    A(1,1) = A(0, A(1,0)) = A(0, A(0,1)) = A(0, 2) = 2 + 1 = 3.
\end{equation}
$A(1,1) = 3$, $A(2,1) = 5$, $A(2,3) = 9$, $A(4,4) = ...$.

Почему можно вычислить за конечное время? Либо $n$, уменьшается, либо $m$.
Рано или позджно $m$ достигнет нуля, однако вычислить реально такую
функцию очень сложно.

Полнота по Тьюрингу. Исполнитель называется тьюринг-полным, если на нём можно
реализовать любую вычислимую функцию. Большинство современных языков
программирования --- Тьюринг-полные. Как доказать --- реализацией машины
Тьюринга на языке.

Теорема о структурном программировании (теорема Бёма -- Якопини, 1965): любая
программа может быть представлена в виде блок схемы с тремя управляющими
структурами: последовательностью, ветвлением и циклом. P\" --- первый полный
по Тьюрингу язык программирования без оператора goto.

FORTRAN, Formula translator, 1954 (первый компилятор)--1957 (оптимизирующий компилятор), IBM.
Первый язык высокого уровня с практическим применением. Начальная цель --- существенно сократить
число строк кода в программе (по сравнению с ассемблером).

Что такое компиляция? Компилятор анализирует ВЕСЬ текст программы, и преобразует его в машинный
код (в низкоуровневый язык, промежуточное представление и т. п. --- что-то положить в такой-то
регистр и т. п.). В простейшем случае работает,
заменяя (транслируя) высокоуровневые функции языка в низкоуровневый код. Например, вместо
\mintinline{cpp}{sqrt(x)}
подставляет конкретный алгоритм вычисления корня. Или (в фортране
появились) --- комплексные числа. На самом деле корень и т. п. вычисляются на floating point unit
(модуль операций с плавающей запятой) внутри процессора --- в нём алгоритмы уже зашиты аппаратно.

Оптимизирующая компиляция.
\begin{minted}{cpp}
    // пусть t на этапе компиляции неизвестно
    x = 0.5 * pi;
    y = pi * pi / 4 - pow((x - pi), 2) + t; // -> t
    x = sin(x + y) + sin(x - y); // -> 2 * cos(t) * sin(x) -> 2 * cos(t)
    // => вдвое меньше нужно вычислять тригонометрических функций!
\end{minted}
На самом деле такая оптимизация возможна только при ffast-math.

Типы данных. Компилятор может производить их анализ (если язык со строгой типизацией) и выдавать
ошибку в случае нарушений:
\begin{minted}{haskell}
    (1 :: Int) / (2 :: Int) -- Error - *div* should be used
\end{minted}

ALGOL (1958 - 1960). Получил распространение как практический язык (в Европе), и как академический
--- для публикации алгоритмов. Программа могла состоять из блоков --- отдельных частей. Ветвления,
циклы, последовательности блоков. Впервые (из промышленных языков) появилась возможность создания
рекурсивных процедур.

На каких машинах это работало? СССР - Большая электронно-счётная машина 6 (1968 --- пошла в серию,
1 млн. операций в секунду, как у американских конкурентов). Были свои трансляторы Фортрана и
Алгола.

LISP. List processing --- обработка списков. Джон Маккарти. Первый интерпретатор - 1958 г. Основан
на идее списков (S-expressions) и ссылках (указателях). Очень простой для синтаксического разбора.
Система автоматического управления памятью, сборщик мусора. Мотивация --- задачи искуственного
интеллекта (шахматы, например).

C. Деннис Ритчи, Bell Labs (aka AT\&T), 1969 -- 1973. Компилируемый статически типизированный язык.

C++, Бьёрн Страуструп, Bell Labs. Начало 80-х. Изначально --- усовершенствования Си для
моделирования телефонный вызовов (теория очередей). Язык стандартизирован, стандарты теперь ---
каждые 3 года. Очень сильное развитие по сравнению с ранними версиями.
1998 — C++ ISO standart. C++11, C++14, C++17, ...

Почему C++? Язык общего назначения, высокая эффективность, широко распространён (много
библиотек), гибкий механизм для конструирования пользовательских типов данных и абстракций,
возможность использовать разные парадигмы программирования, компилируемый, статические типы
данных.
Высокопроизводительные научные вычисления. Сейчас выбор языка уже не так очевиден, хотя
по производительности (предельной) конкуренты только догоняют.

Современное компьютерное моделирование. Что такое наука? Научное знание умещается у человека в
голове. Гипотеза, теория, экспериментальное опровержение. Проблема масштабов и размерностей ---
проблема многих электронов, атомные ядра, многомасштабность в GRBs.

    Задачки на двоичную систему. $2_{10}$, $100_2$. $63_{10}$, $10111_2$. 16-ричная система.
    $64_{10}$, $\mathrm{0xfff}$.

\subsection{Введение в C++}

Типы данных. Статические типы, проверка на этапе компиляции позволяет избежать множества ошибок.
Перегрузка функций.
bool, char, int (2 байта, т.е. 15 бит на значение и 1 бит на знак, $2^{15} - 1 = 32767$),
float, double (8 байт, IEEE 754, binary64, bit for sign, 11 bits for exponent and 53 bits for
fraction,
\begin{equation}
    (-1)^s \left(1 + \sum_{i = 1}^{52} b_{52 - i} 2^{-i} \right) \times 2^{e - 1023},
\end{equation}
 $3 = (2 \times 1.5)$). sizeof()

\begin{minted}{cpp}
#include <iostream> 

using namespace std;

int main( ) { 
    cout << "Hello, world!\n"; 
    return 0; 
    }
\end{minted}

Имена переменных. Инициализация. Оператор присваивания. Арифметика.
\mintinline{cpp}{\%, ==, !=, ++x, +=, \%=}.
\begin{minted}{cpp}
    int k = 18;
    double pi = 3.14159;
    char c = ...;
    z = sqrt(pi); // error - типа нет
\end{minted}

\subsection{Euclid}

(Задача о том, что $p^2 - 1$ делится на 24).

Числа  --- это интересно. Они простые, но образуют очень разнообразные узоры. Например, группы с
умножением по модулю, или простые числа. Сколько простых чисел, меньших заденного целого числа?
Группы Галуа, вязвны с геометрией.

НОД (наибольший общий делитель) двух чисел --- наибольшее число, на которое оба делятся. Как
искать? Перебором?
Строго следовать определению? Составить
таблицу делителей для каждого числа, выбрать совпадающие и найти из них максимальный. Было бы очень
громоздко!

Чем плоха
таблица? Ограниченность, трудно проверить (нужно проверять все числа, а не доказывать алгоритм,
который будет работать для всех. Другой способ --- воспользоваться свойствами функции НОД$(x, y)$ (инвариантность).
Алгоритм
Евклида (Дейкстра, стр. 18). Машина для вычисления НОД$(X, Y)$: лист картона с начерченными линиями
$x = const$, $y = const$, $x + y =
const$ и $x = y$. Если фишка не находится на линии ответа ($x = y$), рассматриваем наименьший
равнобедренный прямоугольный треугольник, у которого вершина прямого угла совпадает с фишкой, а
конец гипотенузы (либо слева, либо снизу фишки) находится на одной из осей. Фишка перемещается в
другой конец гипотенузы, и всё повторяется сначала. Как доказать? Новая точка $x' = x$, $y' = y -
x$, либо $x' = x - y$, $y' = y$. Можно доказать, что НОД$(x, y) = $НОД$(x', y')$, т. е. НОД ---
инвариант нашего преобразования ($x - y$ делится на НОД, числа совпали --- сами себе НОД, и НОД не
может быть больше их, поскольку они на него делятся). Очевидно, конечное число шагов перенесёт
фишку на линию ответа.

Нашем программу, запрашивающую два натуральных числа и выдающую их НОД. Программа
должна использовать оба варианта --- с рекурсией и без, не должна
использовать операцию остатка от деления, а должна использовать алгоритм Евклида, должна
производить сопутствующие проверки (отрицательность, равенство нулю).

Рекурсия на машине Тьюринга (в ф-ии Аккермана, например). К задаче --- Бом--Якопини не требуют
рекурсии.

Напишем программу с рекурсией.
Top-down метод. Легче сначала написать программу с функцией-заглушкой, потом написать простую
функцию через рекурсию, потом без рекурсии, потом добавить проверки...

Первая версия --- Hello, world.
\begin{minted}{cpp}
// euler.cpp
#include <iostream>
using namespace std;

int main() {
    cout << "Hello, world!\n";
    return 0;
}
\end{minted}

Пытаемся скомпилировать и запустить. Добавляем чтение переменных:
\begin{minted}{cpp}
    int a, b;
    cout << "Введите первое число:\n";
    cin >> a;
    cout << "Введите второе число:\n";
    cin >> b;
    cout << "a + b = " << a + b << "\n"; // minted bug
\end{minted}

Для реализации нам понадобится рекурсивная функция gcd (greatest common divisor).
\begin{minted}{cpp}
int gcd(int x, int y) {
    if (x < 0) { // проверка
        return gcd(-x, y);
    } else if (y < 0) {
        return gcd(x, -y);
    } else if (x > y) {
        return gcd(x - y, y);
    } else if (x < y) {
        return gcd(x, y - x);
    } else {
        return x;
    }
}

int main() {
    int a, b;
    cout << "Введите первое число:\n";
    cin >> a;
    cout << "Введите второе число:\n";
    cin >> b;
    cout << "НОД = " << gcd(a, b) << "\n"; // minted bug
    return 0;
}
\end{minted}

\begin{minted}{bash}
    $ g++ euler.cpp # cl euler.cpp
    $ ./a.out # a.exe
\end{minted}

Для версии без рекурсии понадобятся циклы.
\begin{minted}{cpp}
    for(int i = 0; i < 10; ++i ) { // тело выполняется,
                                   // пока выполнено условие i < 10
          cout << i << ...;
    } // можно без {}, но лучше ставить

    // i++ сначала возвращает, потом прибавляет; i++ наоборот
    // i = ++i++; // неопределенное поведение
    for(int i = 0; i<10; cout << ++i << ...) 
        ; // даст 1...10, i++ даст 0...9

    //  while (statement) { expression }
    //  do { expression } while (statement); // тело выполнится хоть один раз

    // gcd без проверок
    /* while (x != y) {
        while (x > y) {
            x = x - y;
        }
        while (x < y) {
            y = y - x;
        }
    } // not beautiful
    */
    while (true) {
        if (x > y) {
            x = x - y;
        } else if (y > x) {
            y = y - x;
        } else {
            break;
        }
    }
\end{minted}

Сложность алгоритма? Сколько операций нужно?

\textit{Задача, множитель 1, deadline 12 апреля}.
Для любого заданного $r \geq 0$ найти все существенно различные формы представления $r$ в виде:
\begin{equation}
    r = x^2 + y^2, \qquad and \qquad x \geq y \geq 0.
\end{equation}
($25 = 3^2 + 4^2 = 5^2 + 0^2$). Для определённости пусть программа выдаёт список пар $(x,
y)$, упорядоченный по возрастанию $x$. Для $74*74*41*41*25*25$ должно получиться $(55370,51840),(56248,50886),..$.

\subsubsection{Фундаментальная теорема арифметики}

Любое натуральное число, большее единицы, имеет единственное разложение на простые сомножители.

Будем считать доказанным, что такое разложение существует. И предположим, что оно не единственное:
\begin{equation}
    N = p_1 \cdot ... \cdot p_r = q_1 \cdot ... \cdot q_s.
\end{equation}
Тогда существует $p_i$, являющееся делителем $N$, но не являющееся делителем ни одного из $q_1, ...
q_s$. Для примера пусть $s = 2$, и пусть $q_1$ не делится на $p_i$. Покажем, что $q_2$ при этом
делится на $p_i$, что докажет нашу теорему. НОД$(p_i, q_1) = 1$ --- числа не делятся. Применим
алгоритм Евклида задом наперёд: $x''^{...} = $НОД$=1$, в то же время $x''^{...} = np_i + mq_1$ (на
первом шаге это так, далее --- по индукции), где $m, n$ --- целые числа (могут быть $<0$):
\begin{equation}
    np_i + mq_1 = 1.
\end{equation}
Умножим на $q_2$:
\begin{equation}
    np_i + mN = q_2.
\end{equation}
$p_i$ является делителем левой части, следовательно --- она делитель и правой части. Теорема
доказана.

Похожая теорема для полиномов (из Галуа)...

\subsection{Задача из Дейкстры (стр. 187) о наименьшем простом множителе большого числа}

Сколько всего простых чисел? Легко доказать, что их бесконечно много. Доказательство Евклида: пусть
есть список простых чисел $p_1$, $p_2$, ... $p_n$. Рассмотрим число $p_1 p_2 ... p_n + 1$. Оно
не делится ни на одно из $p_i$, следовательно оно содержит множителем новое простое число (либо само по себе
простое). Примеры: $2 *
3 + 1 = 7$, $2 * 3 * 5 + 1 = 31$, $2*3*...*11 + 1 = 2311$, простые; составные: $2 * 3 * 5 *
7 * 11 * 13 + 1 = 30031 = 59 * 509$.

Логично исследовать простые числа в качестве возможных множителей в порядке их возрастания.
Максимальный простой множитель не превосходит корня квадратного из этого числа. Если мы не найдем
множителя вплоть до этого корня, это будет значить, что наше число --- простое. Тогда код программы
мог бы быть таким:
\begin{minted}{cpp}
    long long f = 2;
    while (N % f != 0 && f * f < N) {
        f = next_prime(); // how to do this?
    }
    if (N % f != 0) {
        return N; // N is prime
    } else {
        return f;
    }
\end{minted}
Хранение простых чисел в таблице предполагаем невозможным, поскольку исходное число, $N$, считаем
большим (это потребует хранения $O(N^2 / \log N)$ чисел, трюк с корнем существенно
ослабляет требования по хранению, но все равно будем считать хранение неприемлимым). Число можно
вычислять, проверяя на простоту $f + 1$, $f + 2$ и т. д., но проверка на простоту сводится к
проверке, равно ли число своему минимальному простому множителю! Но наименьший простой множитель
числа $N$ является одновременно наименьшим натуральным числом, на которое делится N. Поэтому можно
уйти от проверки на простоту.

\inputminted{cpp}{prime-factors.cpp}

Можно проверить 2 отдельно и дальше проверять только нечетные и т. д., это несколько ускорит, но
усложнит код. Можно упростить вычисление остатка от деления и т. п., но принципиально сложность
вычислений это не изменит.

Если считать вычисление остатка от деления простой операцией, то для нахождения минимального
простого множителя потребуется не более $\sim \sqrt{N}$ операций, сложность $O(\sqrt{N})$. Казалось
бы --- это немного, но если смотреть на зависимость от числа цифр, то получается экспонента: $N
\sim 10^m$ даст сложность $O(10^{m/2})$. Например, максимальное 256-битное число есть $\approx 1.15
\times 10^{77}$, вычисление минимального простого множителя для него может потребовать $10^{38}$
операций!

Мы легко теперь можем найти разложение числа на простые множители (найдем первый, разделим на него
--- далее повторим процедуру поиска, за $O(\sqrt{N})$). Где их хранить? Оперативная память. Стек и
куча (stack and heap). Стек (стопка), Тьюринг, 1946 г. список элементов, организованных по принципу LIFO
(англ. last in — first out, «последним пришёл — первым вышел»). Пример: вычисления в обратной
польской записи. Указатели. Локальные переменные
процедур размещаются в стеке, при вызове процедур процессор помещает в стек адрес команды,
следующей за командой вызова подпрограммы. Куча. Фрагментация. Управление памятью в куче гораздо сложнее.

\begin{minted}{cpp}
    // simple stack arrays
    int a[5]; // const int, const size_t, etc.
    a[0] = 42;
    std::cout << a[0] << "\t" << a[1] << "\n";
    // g++ warning: a[1] is used uninitialized
    int b[]{1,2,3};
    std::cout << b[0] * b[1] * b[2] << "\n";

    // see also std::array

    // heap arrays, динамические массивы;
    void* p; // указатель на объект неизвестного типа,
             // бывает полезно при преобразовании типов
    int* pi = new int; // int *pi = new int;
    *pi = 3;
    void* pv = pi; // ok
    // cout << *pv << endl; // error
    // могут быть очень большими, много больше стека!
    int main (){
        int n = 10;
        double* d = new double[n];
        d[0] = 3.14;
        cout << d[0] << endl;
        delete[] d;
        return 0;
    }

    // 2d array
    int nx, ny; // потенциальная ошибка...
    nx = 30003;
    ny = 25001; // уже не ограничены стеком
    double** a = new double*[nx]; // ...должны были использовать size_t
    for (int i=0; i < nx; ++i) {
        a[i] = new double[ny];
    }
    a[nx-1][ny-1] = 2.7;
    cout << a[nx-1][ny-1] << "\n";
    for (int i=0; i<nx; ++i) {
        delete[] a[i];
    }
    delete[] a;
    return 0;
    // другой способ --- использовать одномерный массив,
    // с ним порядок прохождения циклов будет не важен
\end{minted}

Ссылки, передача по указателю в функцию - добавить сюда!

\section{Lehmer random number generator}

Компьютер --- детерменированное устройство (если нет специальной карты для генерации физического
шума), поэтому не может генерировать случайные последовательности чисел, но может генерировать
псевдослучайные последовательности чисел, то есть такие, которые по своим свойствам в определённом
смысле похожи на действительно случайные последовательности. Для многих приложений (интегрирование
методом Монте Карло, криптография) этого достаточно.

В качестве примера генерации псевдослучайных чисел рассмотрим алгоритм Лехмера. На первый взгляд он
очень простой: следующее псевдослучайное число получается из предыдущего так:
\begin{equation}
    x_{i + 1} = a x_i \mod p.
\end{equation}
Здесь используется операция << умножение по модулю $p$ >>, результат которой есть остаток от
деления на $p$ результата уможения $a x_i$. Например, $2 \times 2 \mod 3 = 1$.

Какие нужно взять $a$ и $p$, чтобы получить <<хорошее>> распределение псевдослучайных чисел и что
вообще значит <<хорошее>>? Давайте посмотрим, что происходит с последовательностью $1..p-1$ при
умножении на $a$, например, для $p = 4$:
\begin{table}[h]
    \centering
    \begin{tabular}{ c | c | c }
        $x_i$ & $2 x_i$ & $3 x_i$ \\
        1 & 2 & 3 \\
        2 & 0 & 2 \\
        3 & 2 & 1 \\
    \end{tabular}
\end{table}
Средний столбец выглядит ужасно --- наш <<генератор>> при $a = 2$ будет генерировать
последовательность нулей для любого входного числа! При $a = 3$ наш генератор будет всегда выдавать
$2$, если $x_0 = 2$, и последовательность $1,3,1,3...$, если $x_0 = 1$ или $3$.  Попробуем взять $p
= 5$:
\begin{table}[h]
    \centering
    \begin{tabular}{ c | c | c | c }
        $x_i$ & $2 x_i$ & $3 x_i$ & $4 x_i$ \\
        1 & 2 & 3 & 4 \\
        2 & 4 & 1 & 3 \\
        3 & 1 & 4 & 2 \\
        4 & 3 & 2 & 1 \\
    \end{tabular}
\end{table}
Здесь всё в порядке (для $a = 2$ или $a = 3$) --- для любого начального числа мы проходим целиком все возможные значения от
$1$ до $p - 1$. Очевидно, что генерируемая последовательность --- периодическая, и период нашей << случайной >> последовательности не может быть
больше, чем $p-1$. То есть мы в данном примере получили максимально возможный период. Кроме того,
каждое число в последовательности на периоде встретится ровно один раз, таким образом, наш
генератор даёт равномерное распределение << случайных >> чисел.

На таких примерах можно прийти к гипотезе, что в качестве $p$ нужно брать
простые числа. Гипотезы в математике очень важны --- иногда они существуют недоказанными многие
годы, существенно влияя, тем не менее, на развитие науки. Так, великая теорема Ферма оставалась
недоказанной около 300 лет.

Интересным примером гипотезы, которая так и не стала теоремой, является гипотеза Эйлера: для любого
натурального $n > 2$ уравнение
\begin{equation}
    \sum_{i = 1}^{n - 1} a_i^n = a_n^n
\end{equation}
не имеет решения в натуральных числах. Например, $a_1^3 + a_2^3 = a_3^3$. Для $n = 3$ гипотеза
верна, для $n = 5$ была опровергнута в 1966 г. с помощью одного из самых <<мощных>> на тот момент
компьютеров, с помощью достаточно <<хитрого>> перебора. Математическая статья, в которой
опровергалась гипотеза Эйлера, состояла буквально из одного предложения:
\begin{equation}
    27^5 + 84^5 + 110^5 + 133^5 = 144^5.
\end{equation}

Вернёмся к генератору Лехмера. Можно доказать следующую теорему.

{\bf Теорема}. Если $p$ --- простое число, то умножение последовательности чисел $1..(p - 1)$ на
любое число $a \in [1, p - 1]$ эквивалентно перестановке последовательности чисел.

Доказательство --- от противного. Предположим, что два числа совпали, то есть
\begin{equation}
    a c_1 \mod p = a c_2 \mod p,
\end{equation}
тогда $a (c1 - c2) \mod p = 0 $, то есть $a (c1 - c2) = n p$.  Последнее равенство не может быть
выполнено, поскольку $a < p$, $|c_1 - c_2| < p$, а $p$ --- простое. Другими словами, при разложении
произведения $a (c1 - c2)$ на множители мы должны среди множителей получить $p$, но каждое из чисел
$a$, $c_1 - c_2$ меньше $p$.

{\bf Следствие 1}. Множество чисел $1..(p - 1)$ с операцией умножения по модулю $p$, где $p$ --- простое,
образуют группу.

Группа --- это множество с ассоциативной операцией (<<умножением>>), для которой в множестве есть
нейтральный элемент (единица; любой элемент не меняется при умножении на неё) и для каждого
элемента есть обратный. Например, группой является множество чисел $1, 2,.., n - 1$, с операцией
сложения по модулю $n$. Единицей в такой группе является число $0$. Такая группа часто обозначается
$\mathbb Z_n$. В качестве упражнения можно попробовать доказать существование обратных элементов
для всех чисел из группы.

В группе, образованной числами $1..(p-1)$ c операцией умножения по модулю $p$, как мы уже доказали,
умножение на $a$ эквивалентно перестановке. Следовательно, при умножении на $a$ единица окажется на
каком-то новом месте, а значит, элемент, обратный для $a$, стоял на месте единицы, таким образом
для любого $a$ существует обратный.

Попробуем ответить на вопрос: какое взять число $a$, чтобы для данного простого $p$ для любого
$x_0$ получался бы максимальный период? Как уже было отмечено, если мы получим максимальный период
($p-1$), то мы построим генератор случайных чисел, дающий, во-первых, много чисел, и, главное ---
дающий числа, имеющие равномерное распределение --- каждое число даст все другие значения по одному
разу. Мы увидим, что для поиска нужного $a$ нам не обязательно переберать для каждого кандидата все
возможные $x_0$.

{\bf Следствие 2}. Множество чисел $1,\; a,\; a^2, ...$, где под умножением подразумевается
умножение по модулю $p$ (следовательно, это конечное множество --- пока не встретится повтора),
образует группу.

Это множество содержится в множестве всех чисел $1...(p=1)$, то есть оно образует
подгруппу группы из следствия 1. Множество $1,\; a,\; a^2, ...$ по определению конечно, в то же время умножение на $a$ эквивалентно
перестановке нашего множества (может показаться, что умножение на $a$ выведет какой-то из элементов
из нашего множества, но по процедуре построения нашего множества этого не может случиться).
Таким образом, единица будет присутствовать в переставленном
множестве, и $a^{-1}$ в исходном множестве находился на том месте, где появилась единица, то есть
$a^{-1}$ в исходном множестве также есть. Отсюда следует интересный вывод: можно не перебирать все $x_0$ для
каждого $a$, а возводить $a$ в степень до тех пор, пока не получится $1$. Если для этого
пришлось возвести $a$ в степень $p$ (то есть при меньшей степени единица не встретилась), то мы
нашли хорошее $a$. Группа, получающаяся из степеней одного и того же элемента (как в нашем случае),
называется циклической, а этот элемент --- образующим группы.

Как долго потребуется возводить $a$ в степень в случае, если в конечном итоге число элементов в
подгруппе $1, a, a^2...$ окажется меньше, чем $p - 1$?  Теорема Лагранжа отвечает на этот вопрос:
порядок (число элементов) конечной группы $G$, для которой группа $H$ --- подгруппа, делится на
порядок группы $H$. Мы не будем её доказывать; наиболее простое и красивое доказательство этой
теоремы использует понятие смежных классов, и может быть легко найдено в Сети.

Из теоремы Лагранжа следует, что порядок нашей подгруппы $1,\; a,\; a^2, ...$ (число элементов)
является делителем для $p - 1$. Например, для $p = 7$: период последовательности $1$, $2$, $2^2 =
4$ ($2^3 = 1$) равен $3$, что делит $p - 1 = 6$. Для $a = 3$ период равен $6$, то есть максимально
возможный.  Таким образом, для создания <<хорошего>> генератора мы можем выбрать простое и
достаточно большое $p$, и $a$ такое, что его степени дадут полную последовательность $1..(p - 1)$
(для поиска таких чисел на самом деле существуют более эффективные методы, чем рассмотренный здесь
перебор, при котором мы идём, пока не встретим единицу). Тогда при любом $x_i$ (он окажется одной
из степеней $a$) мы получим максимально возможный период, а генератор будет давать равномерно
распределённые псевдослучайные числа.

В C++11 функция \mintinline{cpp}{minstd_rand} использует $p = 2^{31} - 1 = 2\,147\,483\,647$ и $a =
48271$ (оба числа простые). Максимальный делитель $p - 1$ есть $331$, поэтому даже перебор всех
возможных $a$ был бы не очень долгим.

У генератора Лехмера можно обеспечить большой период и равномерность распределения, но мы не
контролируем другие его статистические свойства. Например, параметры
можно выбрать настолько плохо (как в случае известного генератора RANDU), что в трёхмерном пространстве (первое число --- координата
по $x$, второе --- по $y$, третье --- по $z$) точки, сгенерированные таким методом, лягут всего на (около) 15
плоскостей. Также может оказаться, что если смотреть на минорные (младшие) биты сгенерированных
чисел, то окажется, что последовательность, составленная из них, имеет гораздо меньший период, чем
$p - 1$. Например, при совсем неудачном выборе параметров можно получить чередование чётных и нечётных
чисел. Поэтому в настоящее время распространение получили другие генериторы псевдослучайных чисел,
такие
как генераторы семейства xorshift (например, xorshift1024*).

\subsection{Быстрое возведение в степень и абстракции в C++}

\clearpage

{\it Задача}. Попробуйт ответить на следующие вопросы. Что такое область видимости
(scope) и время жизни (lifetime) переменной? Где (в стеке или в куче) хранятся переменные
\mintinline{cpp}{a, b, c, d} программы ниже? Где хранится код функции \mintinline{cpp}{f}? Где
потенциальная ошибка в приведённой программе, и что она выведет на экран?

\inputminted{cpp}{lifetime.cpp}

Из приведённого примера становится ясно, что хранение локальных переменных с использованием стека и
время жизни, ограниченное блоками, окружёнными фигурными скобками, прекрасно сочетаются. Так,
создать <<пропуск>> в стеке практически невозможно, то есть невозможно создать ситуацию, при
которой переменная, область видимости которой закончилась, будет <<закрыта>> в стеке переменной
<<сверху>> и не сможет быть удалена из стека. На самом деле, такой ситуации можно бы было добиться
с использованием ключевого слова \mintinline{cpp}{static}, которое позволяет создавать переменные с
временем жизни, большим области видимости (такие переменные инициализируются при первом выполнении
строки с их объявлением, и живут до конца работы программы). Также <<дыры>> в стэке можно было бы
добиться с помощью передачи переменной по ссылке в многопоточной программе, однако, как мы увидим,
в стандартной реализации (C++11) передача аргументов в функцию, исполняемую другим потоком,
возможна только через копирование.

\clearpage

\section{Алгоритм быстрого возведения в степень (exponentiation by squaring)}

Если следовать определению, то возведение числа в целую положительную степень можно было бы
реализовать примерно так:
\begin{minted}{cpp}
    // n^m
    int n = 5;
    int m = 3;
    int p = 1;
    for (int i = 0; i < m; ++i) {
        p = p * n;
    }
    std::cout << p << '\n'; // 125
\end{minted}
При этом, очевидно, сложность данного алгоритма есть $O(m)$.

Еще в XV веке был предложен гораздо более быстрый алгоритм. Рассмотрим сначала его суть на
простейших примерах. Число $2^5$ может быть представлено как $2 \times 2 \times 2 \times 2 \times
2$ (4 умножения), с другой стороны, можно выделить возведения в квадрат: $2^5 = 2 \times a$, $a = b
\times b$, $b = 2 \times 2$ (3 умножения). Как это можно формализовать? Если степень нечётная --- просто
умножаем ответ на множитель (степень при этом уменьшается на единицу), если чётная --- возводим
множитель в квадрат (степень при этом делится на два!). Итерируем до тех пор,
пока степень не иссякнет. Благодаря делению степени на два (как минимум, на каждой второй итерации
алгоритма), сложность возведения в степень данным методом будет $O(\log m)$. Реализуем этот
алгоритм на C++:
\begin{minted}{cpp}
    // n^m; exponentiation by squaring
    int n = 2;
    int m = 15;
    int p = 1; // for result
    while (m != 0) {
        if (m % 2 == 1) {
            m = m - 1;
            p = p * n; // for instance, 2^15 = 2 * 2^14
        } else {
            n = n * n;
            m = m / 2; // for instance, 2^14 = (2 * 2)^7
            // do nothing with p in this case
        }
    }
    // Example:
    // 2^15 = 2 * 2^14 = 2 * 4^7 = 2 * 4 * 4^6 = 2 * 4 * 16^3
    // = 2 * 4 * 16 * 16^2 = 2 * 4 * 16 * 256 = 32768
    std::cout << p << '\n';
\end{minted}

Если мы оформим этот алгоритм в виде функции, то сможем его несколько улучшить, например, явно
указав (с помощью типа), что степень --- целое беззнаковое число. Но наиболее заметное улучшение
можно сделать, заметив, что в натуральную степень можно возводить не только \mintinline{cpp}{int},
но и \mintinline{cpp}{long int}, \mintinline{cpp}{unsigned long int, float, double}, хотя с числами
с плавающей запятой можно несколько потерять точность. Подобные обобщения (абстракции) очень часто
встречаются в математике, где теоремы стараются формулировать наиболее <<широко>>.

\subsection{Параметрический полиморфизм}

Как обобщение, описанное в конце прошлой части, можно реализовать? Самый простой способ ---
скопировать код нашей функции много раз, и заменить в этих копиях тип аргумента, которой возводится
в стемень, на те типы, которые нам нужны. Такой подход возможен --- C++ допускает существование в
коде функций, имеющих одинаковое имя, но разный тип аргументов (такая возможность называется
перегрузкой функций). Однако подобный подход имеет ряд существенных проблем. Во-первых, нельзя
заранее предусмотреть, какие именно типы нам понадобятся. В частности, при написании библиотеки
(кода, которым в своих программах будут пользоваться другие программисты) вообще неизвестно, какие
типы понадобятся в будущем (а ведь бывают еще и типы, определённые пользователем!), и такой подход
оказывается в принципе невозможным. Во-вторых, такой код было бы очень трудно поддерживать и
сопровождать. Предположим, что в нашей функции обнаружилась ошибка. Для её исправления нам пришлось
бы переписать все варианты нашей функции, полученные через copy-paste, и никто не гарантирует, что
мы смогли бы их все переписать правильно, не внеся новых ошибок.

Для поддержки абстракций в коде (абстракции такого типа называют <<параметрическим полиморфизмом>>)
и решения описанных проблем был придуман мехинизм шаблонов. Упрощенно его работу можно представить
так. Перед компиляцией исходный код пропускается через программу-предпроцессор, которая ищет вызовы
шаблонных функций и определяет, для каких конкретных типов потребуются реализации шаблонов. После
этого программа-предпроцессор копирует код шаблона, подставляя в качестве шаблонного типа типы, для
которых нужны реализации данной функции. После этого получается код, в котором определены все
функции, которые в нём встретятся. Хотя все эти функции имеют одно и то же имя, но за счёт
поддержки перегрузки функций данный код уже может быть отдан компилятору.

Рассмотрим простой пример.  Чтобы возводить в квадрат (и, главное, получать в качестве результата)
разные типы, используем шаблон.
\begin{minted}{cpp}
    #include <iostream>

    // шаблон; вводим абстрактный тип T,
    // а затем используем его
    template <typename T> T squared(T a) {
        return a * a;
    }

    int main() {
        //         здесь T = double
        std::cout << squared<double>(3.14) // получим 9.8596
                  << '\t'
                  //     T = int
                  << squared<int>(2) // результат = 4
                  << '\n'
                  ;
        return 0;
    }
\end{minted}
При использовании шаблонных функций не обязательно указывать тип в треугольных скобках --- он часто
может быть выведен из типа аргументов функции [например, в случае \mintinline{cpp}{squared(3.14)}
очевидно, что \mintinline{cpp}{T = double}]. Однако не стоит этим злоупотреблять (как минимум,
чтобы программу было проще читать и чтобы не запутаться самому).  Например, в Python
параметрический полиморфизм реализован на первый взгляд проще, но при его использовании гораздо
проще совершить ошибку, по сравнению с C++:
\begin{minted}{python}
    # определение полиморфной (по обоим аргументам!) функции div
    def div(a, b):
        return a / b

    print(div(2, 3)) # int или float?
\end{minted}

Вернёмся к возведению в степень, воспользовавшись шаблонами:
\inputminted{cpp}{pow.cpp}
Размер кода почти не изменился, и теперь у нас есть удобная, понятная функция и её можно
использовать для множества типов!

В C++ шаблоны, как уже было сказано, реализуются, по сути, с помощью копирования кода шаблона и
подстановки того типа, для которого в программе будет вызвана шаблонная функция. На самом деле этот
механизм работает не только для типов, но и для значений (так называемые шаблоны с нетиповыми
параметрами).  При этом, как можно заметить, возможна ситуация, когда одного прохода по коду
недостаточно для того, чтобы определить все значения параметров, необходимых для подстановки в
шаблон, но такой случай также предусмотрен в языке и не является проблемой для компилятора:
\inputminted{cpp}{fac-template.cpp}
При использовании оптимизирующего компилятора вычисление факториала в данном примере будут
проведено еще на этапе компиляции, а в машинном коде уже будет содержаться ответ.

\clearpage

\subsection{Пользовательские типы}

Во многих задачах мы имеем дело с объектами, для которых нет подходящего типа среди стандартных
типов C++, например, в стандартной библиотеке нет матриц и функций из линейной алгебры. Однако C++
позволяет определять пользовательские типы, такие же удобные, как и встроенные типы. Так, есть
возможность самостоятельно определить матрицы, и переопределить для них (например) оператор
умножения.

В простейшем случае новые типы можно определять, используя структуры:
\begin{minted}{cpp}
    #include <iostream>

    struct pair {
        int a;
        int b;
    }; // обратите внимание на точку с запятой

    int main() {
        pair p = {2, 3}; // или {2, 3,};
        p.a = p.a + p.b;
        std::cout << p.a << '\n'; // 5
        return 0;
    }
\end{minted}
Для работы с \mintinline{cpp}{pair} мы можем определить различные функции. Однако сразу стоит
оговориться, что при передаче арнумента в функцию происходит его копирование, и внутри функции мы
работаем с копией. Это значит, прежде всего, что мы можем потерять в производительности кода (если
функция выполняет мало действий, но вызывается много раз) и в потреблении памяти (если передаваемая
структура очень много <<весит>>). Чтобы избежать подобных проблем, используют передачу по ссылке,
при которой копирования не происходит, а изменения происходят с передаваемым объектом:
\begin{minted}{cpp}
    void f(int x) { // передача по значению
        x = x + 1; 
    }

    void g(int& x) { // передача по ссылке
        x = x + 1; 
    }
    // ... 
    int y = 5; 
    f(y); // y по-прежнему равен 5
    g(y); // теперь y = 6
\end{minted}
Если аргумент, передаваемый по ссылке, модифицируется функцией, то его обычно ставят в начало
списка аргументов. Если же он не модифицируется, стоит указать это явно с помощью ключевого слова
\mintinline{cpp}{const} перед его типом. Вместо ссылки (и для тех же целей) можно передавать в
функцию указатель.

Вернёмся к \mintinline{cpp}{pair}.  Наша пара подойдёт, например, для целочисленных коорддинат, или
для времени (часы, минуты), но ни для координаты с плавающей точкой, ни для людей (имя, фамилия),
ни для продуктов в кулинарном рецепте (название, вес) она не годится, хотя во всех этих примерах
также нужны пары. Для обобщения нашей структуры, как легко догадаться, можно воспользоваться
шаблонами:
\begin{minted}{cpp}
    template <typename A, typename B> struct pair {
        A a;
        B b;
    };
    //...
    pair<int, int>           p    = {2, 3};
    pair<std::string, float> kiwi = {"kiwifruit", 0.2}; // разнородная пара
\end{minted}

Шаблоны открывают широкие возможности абстракции, однако ими (как и многим другим) стоит
пользоваться с умом. В частности, не всегда легко понять, какой именно шаблон будет использован в
конкретном месте:
\inputminted{cpp}{oops_templates.cpp}
Почему в этом примере получилось $334$? Для начала ответим на вопрос, какие реализации шаблонов
могут встретяться в нашем коде? Очевидно, это будут: реализация шаблона $3$ для пары из пар целых
чисел (\textit{3-pair-pair}), реализация шаблона $3$ для пары целых чисел (\textit{3-pair-int}),
реализация шаблона $2$ для типа \mintinline{cpp}{pair<int, int>} (\textit{2-pair-int} и реализация
шаблона $2$ для типа \mintinline{cpp}{int} (\textit{2-int}). При вызове \mintinline{cpp}{oops(p)}
вызывается функция \textit{3-pair-pair} (что даёт $100$), которая вызывает две функции:
\textit{3-pair-int} ($+100$) и \mintinline{cpp}{oops<B>(...)}, где \mintinline{cpp}{B} выводится из
типа аргумента функции \textit{3-pair-pair}, то есть \mintinline{cpp}{B = pair<int, int>}. Таким
образом, в этом случае используется шаблон с одним шаблонным параметром, что приводит к вызову
функции \textit{2-pair-int}, а уже она вызывает \textit{3-pair-int} ($+110$)! Каждая из двух
функций \textit{3-pair-int} вызывает функцию \textit{1} и функцию \textit{2-int} ($+22$). Далее,
функции \textit{2-int} вызывают функцию \textit{1} ($+2$). Итого получается, наконец, $334$.
Проследить эту цепочку вызовов довольно легко, добавив в наши функции \mintinline{cpp}{cout}
номеров функций.  Хочется верить, что этот пример не отпугнёт читателя от использования шаблонов, а
научит использовать шаблоны с осторожностью, не смешивая шаблонные и нешаблонные функции, и шаблоны
с разным числом параметров, а заодно не экономить, и писать скобки \mintinline{cpp}{<...>}, там,
где они подразумеваются, не надеясь на автоматический вывод.

Теперь попробуем ответить на вопрос, что будет, если мы вызовем \mintinline{cpp}{oops(r)}? Через ту
же цепочку она приведёт к вызову \mintinline{cpp}{oops<double>(...)} (реализация второго шаблона),
которая рекурсивно вызывает саму себя до бесконечности!

Вернёмся к пользовательским типам, говоря о которых, часто начинают с объектно-ориентированного
подхода, то есть с классов, инкапсуляции и наследования. Здесь мы намеренно откладываем эти темы,
поскольку структур и шаблонов уже достаточно для построения качественного кода, и вполне достаточно
для решения слещующей задачи.

\textit{Задача. Числа Фибоначчи.}
Рассмотрим задачу вычисления чисел Фибоначчи: $F_0 = 0$, $F_1 = 1$, $F_n = F_{n-1} + F_{n-2}$.
Фибоначчи (Леонардо Пизанский, первый крупный математик средневековой Европы, 1170--1250) пришёл к
этой последовательности, как к решению абстрактной задачи о размножении кроликов. Вычислять числа
Фибоначчи можно по-разному. В данном случае требуется написать три функции, вычисляющие число
Фибоначчи для заданного номера $n$ разными способами, и, желательно, измерить время работы функций.
Первый способ --- с использованием простой рекурсии. Второй способ --- с использованием циклов.
Требуется, чтобы вычисление вторым способом было принципиально быстрее, чем первым. Третий способ
связан с тем, что вычисление чисел Фибоначчи можно представить с помощью матриц:
\begin{equation}
    \begin{pmatrix}
        F_n \\
        F_{n-1}
    \end{pmatrix} =
    \begin{pmatrix}
        1 & 1 \\
        1 & 0
    \end{pmatrix}
    \begin{pmatrix}
        F_{n - 1} \\
        F_{n - 2}
    \end{pmatrix} =
    \begin{pmatrix}
        1 & 1 \\
        1 & 0
    \end{pmatrix}^{n - 1}
    \begin{pmatrix}
        1 \\
        0
    \end{pmatrix}.
\end{equation}
Таким образом, задача свелась к возведению матрицы в степень. В данном случае нужно создать
структуры для представления матриц в программе, написать шаблонную функцию для возведения в степень
быстрым алгоритмом (exponentiation by sqyaring), определить оператор умножения для матриц, и
собрать всё это вместе. Для всех трёх способов вычисления необходимо оценить сложность в терминах
$O$-нотации. Программа должна при запуске выводить на экран $F_{9}$, $F_{34}$ и $F_{50}$
(получающиеся значения стоит указать, например, в комментариях в коде).
% $F_{9} = 34$, $F_{34} = 5702887$, $F_{50} = 12586269025$, в последнем случае необходимо для
% возыращаемого значения использовать long long int.

\clearpage

Например, можно написать функцию, поэлементно перемножающую два массива:
\inputminted{cpp}{mult-arrays.cpp}
(не так!!! qwe) При этом, что очень важно, мы избавляемся от ряда возможных ошибок: например, если мы вызовем нашу
функцию для массивов разной длины, код просто не скомпилируется.

\subsection{Задача --- числа Фибоначчи}
Рассмотрим задачу вычисления чисел Фибоначчи. $F_0 = 0$, $F_1 = 1$, $F_n = F_{n-1} + F_{n-2}$.
$F_{12} = ?$.
13 век, задача о кроликах. Эти
соотношения можно представить в виде матрицы:
\begin{equation}
    \begin{pmatrix} F_n \\ F_{n-1} \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0 \end{pmatrix}
    \begin{pmatrix} F_{n - 1} \\ F_{n - 2} \end{pmatrix} = \begin{pmatrix} 1 & 1 \\ 1 & 0
\end{pmatrix}^{n - 1} \begin{pmatrix} 1 \\ 0 \end{pmatrix}.
\end{equation}
Задача --- написать функцию-шаблон для возведения в степень быстрым алгоритмом, вычислить с помощью
неё числа Фибоначчи. Сравнить с рекурсивным и линейным алгоритмами. (Тип
\mintinline{cpp}{long long int} имеет длину не менее 64 бит, \mintinline{cpp}{long int} --- не
менее 32). Вычислите $F_{45} < 2^{31}$, $2^{31} < F_{47} = 2971215073 < 2^{32}$, $F_{50} =
12586269025 > 2^{32}$.  Какой тип возвращаемого значения должна иметь функция для вычисления
каждого из этих чисел?  (Проверка: $F_{9} = 34$, $F_{34} = 5702887$). Ниписать тремя способами.


Передача аргумента по указателю и ссылке. Область видимости, время жизни.
Ссылки. Конструкторы деструкторы, пример! \mintinline{cpp}{& a} читается "ссылка на a".
\begin{minted}{cpp}
    ...
    void f(int x) {
        ++x; 
    }

    void g(int& x) {
        ++x; 
    }
    ... 
    int main() {
        int y = 5; 
        cout << y << "\n"; // 5 
        f(y); 
        cout << y << "\n"; // 5 
        g(y); 
        cout << a << "\n"; // 6
        return 0;
    }
\end{minted}
Передача по указателю...

\subsection{RSA шифрование}

Рональд Ривест, Ади Шамир и Леонард Адлеман, MIT. Изучая группы, на которых построен генератор
Лехмера псевдослучайных чисел, мы получили $a^{p - 1} = 1 \mod p$, если $p$ --- простое число. Для
произвольного, не простого, числа $n$, верно следующее соотношение:
\begin{equation}
    \label{fermat}
    a^{\varphi(n)} = 1 \mod n,
\end{equation}
где $\varphi(n)$ --- функция Эйлера --- число натуральных чисел от $1$ до $n - 1$, являющихся
взаимно простыми с $n$. Если $n$ --- простое, то, очевидно, $\varphi(n) = n - 1$. Доказать
утверждение~\ref{fermat} можно, рассматривавя множество взаимно простых с $n$ чисел от $1$ до $n -
1$. С операцией умножения по модулю $n$ эти числа образуют группу.

Рассмотрим такое $n$, которое разлагается на произведение всего двух простых чисел: $n = pq$. Тогда
не взаимно простыми с $n$ (и меньшими $n$) будут только числа $pi$ и $q j$, с $i = 1, 2, ..., (q -
1)$, $j = 1,..., (p  - 1)$, следовательно,
\begin{equation}
    \varphi(n) = (p q - 1) - (q - 1) - (p - 1) = (p - 1)(q - 1).
\end{equation}
Из~\ref{fermat}
\begin{equation}
    a^{1 + m (p - 1) (q - 1)} = a \mod pq
\end{equation}
--- ключевое соотношение в алгоритме RSA. Предположим, что мы нашли пару чисел $e$ и $d$ таких, что
$de = 1 + m (p - 1) (q - 1)$, то есть $de = 1 \mod (p - 1) (q - 1)$. Тогда мы можем произвести
шифрование, возведя в степень $e$, и дешифрование, возведя зашифрованное число в степень $d$!

Как именно это применяется? Предположим, что Алиса где-то взяла (сгенерировала) числа $p$, $q$, $e$
и $d$. Она может сообщить Бобу пару чисел $(e, n = pq)$ (открытый ключ), не сообщая при этом сами
$p$ и $q$. Тогда Боб может зашифровать своё сообщение $a$, возведя его в степень, $a^e \mod n$ (за
$O(\log e)$ операций), и Алиса сможет также легко расшифровать его сообщение, $(a^e)^d = a$. В то
же время, если кто-то перехватит открытый ключ, для расшифровки сообщения ему потребуется разложить
$n$ на множители, что потребует $O(\sqrt{N})$ операций, то есть экспоненциально сложно по
количеству цифр в $n$.

Где взять большие простые числа $p$ и $q$? Казалось бы, если их находить перебором, то потребуется
слишком много времени на проверку, простые ли они. Однако тесты простоты для чисел
специального вида могут быть проведены гораздо быстрее, чем для произвольных чисел. Например, тест
Люка--Лемера позволяет за полиномиальное время от битовой длины числа Мерсенна ($2^l - 1$)
определить, простое оно или нет.

Здесь следует заметить, что условия компьютерной сети отличаются от условий "прямой видимости"
Алисы и Боба. В сети они передают сообщения только через посредников, которые могут попытаться их
обмануть, осуществив, например, так называемую атаку man in the middle. Суть её в следующем. Алиса
передаёт промежуточному узлу открытый ключ. Промежуточный узел дает Бобу другой (!), свой, открытый
ключ. Боб шифрует им сообщение, промежеточный узел расшифровывает его, читает, и зашифровывает
ключом Алисы, после чего посылает его Алисе. Таким образом, злоумышленник --- промежуточный узел
--- читает всю переписку. Для предотвращения такой атаки необходим другой канал связи между Алисой
и Бобом, который либо недоступен злоумышленнику, либо подмена ключа в котором крайне маловероятна.
Например, Алиса может позвонить Бобу и спросить у него тот открытый ключ, который она передала ему
в компьютерной сети. Если ключ, полученный Бобом, именно тот, что передавала Алиса, то атаки man in
the middle не произошло. Если Боб сообщает Алисе ключ голосом, или в виде картинке (по видеосвязи),
то верояность замены его "на лету" можно считать очень низкой. Хотя в принципе атака man in the
middle не может быть исключена полностью здесь. Таким образом, для создания шифрованного канала
связи нужно однократно использовать дополнительный достоверный канал связи.

В ряде случаев нужно не только зашифровать канал связи, но и скрыть сам факт передачи сообщения от
Алисы Бобу. Как это сделать, если на маршруте в компьютерной сети между Алисой и Бобом находится
злоумышленник? Один из вариантов решения проблемы --- луковая маршрутизация (onion routing),
приближенно сводящаяся к слудующему. Из компьютеров добровольцев создаётся "луковая сеть",
компьютеры которой дают свои ключи шифрования Алисе. Алиса определяет некоторый квазислучайный
маршрут через компьютеры луковой сети, для определенности $3--8--2--1--4--7$, и далее к Бобу. К
своему зашифрованному сообщению она добавляет номер последнего компьютера в маршруте, 7, и шифрует
это ключом предпоследнего компьютера и т. д. Луковая чешуя. Tor browser. Уязвимости. Важно помнить,
что если есть хоть какой-то дополнительный канал связи (но достоверный), то препятствовать
шифрованию невозможно.

\section{Математический маятник. Метод Эйлера и метод средней точки.}

Задача об осцилляторе.

wolframalpha.com: dx/dt=v, dv/dt=-x, x(0) = 0, v(0) = 1

Решение: $x = sin(t), \; v = cos(t)$.

Метод Эйлера: $x_{n+1} = x_n + v_n \Delta t$, $v_{n+1} = v_n - x_n \Delta t$, на Cpp:

\begin{minted}{cpp}
#include <iostream> 
using namespace std;

int main( ) { 
    double x, v, t, dt; // or float
    x = 0; 
    v = 1; 
    t = 10; 
    dt = 0.1; 
    int i; // or long int (long)
    for(int i=0; i < int (t / dt); ++i) { 
        float a = x; 
        x = x + v * dt; 
        v = v - a * dt; 
        cout << x << "\t" << v << "\n";
    } 
    cout << "Bye!\n";
    return 0; 
}
\end{minted}
За $t = 10$ (а чему равен период маятника?) амплитуда доросла до $1.5$! На самом деле она растёт
экспоненциально. При $dt = 0.01$ амплитуда доходит до $1.05$, но поскольку она растёт
экспоненциально, практически никакое уменьшение шага не спасёт на больших временах: при $t = 100$
получаем те же самые $1.5$. Почему так происходит?

Задачи для решения у доски. Написать аналитическое решение для численной схемы Эйлера (ещё один вид
маятника). Решение: $(x_n, v_n) = (x_0, v_0)_\cdot e^{i \omega n \Delta t}$, что даст
\begin{equation}
    (1 - e^{i \omega \Delta t})^2 = -\Delta t^2.
\end{equation}
Дальше можно найти $\omega$ в виде $\omega = \omega_0 + \omega_1 \Delta t + ...$.

Таким образом, проблема не просто в точности решения!

\subsubsection{Midpoint}

Давайте попробуем увеличить точность метода Эйлера и посмотрим, что из этого получится. Из картинки
$x(t)$ понятно, что точность у метода Эйлера хуже там, где кривизна больше. Интуитивно понятно, что
если взять производную в средней точке ($x_{n+1}$ определять через $v_{n + 1/2}$), то точность
решения будет выше. Midpoint, Leap frog.
\begin{eqnarray}
    x_{n + 1} = x_n + v_{n + 1/2} \Delta t, \\
    v_{n + 3/2} = v_{n + 1/2} - x_{n + 1} \Delta t.
\end{eqnarray}
(Внимание на индексы). Во-первых, не для любого уравнения так можно сделать, во-вторых, нужно не
забывать на пол-шага сдвигать, например, скорость в начале. Что при этом будет с устойчивостью ---
задание для решения у доски. Должно получиться $(e^{i \omega \Delta t} - 1)^2 = -\Delta t^2 e^{i
\omega \Delta t}$, что даёт
\begin{equation}
    \sin^2 \frac{\omega \Delta t}{2} = \left( \frac{\Delta t}{2} \right)^2.
\end{equation}
Очевидно, что решение ($\omega$) вещественное, то есть неустойчивости нет, пока $\Delta t < 2$.

\subsubsection{Задача (10.03): pi + период физического маятника}
(7 баллов = 1 б. значение pi, 3 б.
период от амплитуды (картинка, правильная) + 1 б. метод средней точки + 1 б. корректно выбраны начальные
условия + 1 б. линейная аппроксимация для уточнения места нуля скорости.)

Написать программу реализующую метод средней точки для уравнений математического маятника, и
физического маятника:
\begin{eqnarray}
    \frac{dx}{dt} = v, \\
    \frac{dv}{dt} = - \sin x.
\end{eqnarray}
Определить период колебаний, и для математического маятника вычислить из него число $\pi$, а для
физического построить зависимость периода от начальной амплитуды. Присылать шаги и полученное
значение пи, версию с физическим маятником и картинку с периодом от амплитуды.

Что с точностью данных схем? Рассмотрим простое уравнение (получим точное решение численных схем у
доски):
\begin{equation}
    \frac{dx}{dt} = t
\end{equation}
Схема Эйлера нам даст:
\begin{equation}
    x_n = x_0 + \Delta t^2 \sum_{i = 1}^n i = \frac{\Delta t^2 N (N + 1)}{2} = \frac{t^2}{2} +
    \frac{t \Delta t}{2}.
\end{equation}
O-нотация.

Схема midpoint:
Получится точное решение, поскольку на одном шаге схема даёт точное решение.
\begin{eqnarray}
    \frac{x_{n+1} - x_n}{\Delta t} = t_{n+1/2} = (n + 1/2) \Delta t, \\
    x_{n + 1} = x_n + (\Delta t )^2 \times (n + 1/2),
\end{eqnarray}
Если предположить, что $x_n = t_n^2 / 2$, то есть найдено точно, то и $x_{n + 1}$ найдено точно:
\begin{equation}
    x_{n + 1} = \frac{\Delta t^2 (n^2 + 2 n + 1)}{2} = \frac{(n + 1) \Delta t}{2}.
\end{equation}
Начальное условие известно точно ($x_0 = 0$), дальше делаем шаги и т. п.
Другой способ, для любого начального условия --- просто суммируем ряд:
\begin{eqnarray}
    x_{n + 1} = x_n + \Delta t^2 \times (n + 1/2) = \\
    x_{n + 1} = x_{n - 1} + (n - 1 /2) \Delta t^2 + (n + 1 / 2) \Delta t^2 = \\
    x_0 + \Delta t^2 \times \left\{ \sum_{i = 0}^n (i + 1/2) \right\} = \\
    x_0 + \Delta t^2 \times \left\{ \frac{n (n + 1)}{2} + (n + 1) / 2 \right\} = \\
    x_0 + (\Delta t)^2 \times \frac{(n + 1)^2}{2}.
\end{eqnarray}
$x(T = t_N = N \Delta t)$, $n + 1 = N$,
\begin{equation}
    x_n = x_0 +(\Delta t)^2 \times \frac{N^2}{2} = x_0 + T^2 / 2.
\end{equation}
Почему получилось точное решение? Высшие производные равны нулю! Ряд Тейлора для Эйлера и средней
точки. Снова O-нотация.

Не для любой правой части можем написать схему средней точки. Рассмотрим другое уравнение:
\begin{equation}
    \frac{dx}{dt} = -x, \qquad x(0) = 1,
\end{equation}
(Если sin x справа, то уже метод средней точки в простом виде не пройдёт).
Должно получиться $x_{n+1} = e^{-(n+1) \Delta t}$.

Эйлер:
\begin{equation}
    x_{n+1} = x_{n} - \Delta t \times x_n = (1 - \Delta t)^{n + 1} x_0.
\end{equation}
Midpoint (leap frog):
\begin{eqnarray}
    x_{n+1} = x_{n} - \frac{\Delta t}{2} \times (x_n + x_{n+1}), \\
    x_{n+1} = \left\{ (1 - \Delta t / 2) / (1 + \Delta t / 2) \right\}^{n+1} x_0.
\end{eqnarray}
Анализ --- чему равна ошибка на первом шаге. Снова ряд Тейлора (разложим аналитическое решение...).

\section{Простые алгоритмы}

Как вычислять, например, обратное число или корень?
Методы нахождения нуля функции. Метод деления пополам. Метод Ньютона.

Multiplicative inverse algorithm.
\begin{eqnarray}
    b = a^{-1} + x, \\
    ax = ab - 1, \\
    b_{i + 1} = b_i - b_i (ab_i - 1).
\end{eqnarray}
Newton-rhapson algorithm.
$a_{i+1} = (a_i + n / a_i) / 2$

Как эти методы выглядят с точки зрения конечно-разностных схем для решения дифф уравнений?

  $f(0) = 1$, $f(n>0) = \sqrt{2 + f(n - 1)}$. Данная функция связана с
   одним из методов вычисления числа $\pi$ (Лю Хуэй, 265 г. н. э.). Периметр
   правильного шестиугольника, вписанного в окружность единичного радиуса, равен
   $6$. Удваивая число вершин вписанного многоугольника, получаем связь прежней
   длины стороны $M$ с новой $m$:
   \begin{equation}
     1 - \sqrt{m^2 - (M / 2)^2} = \sqrt{1 - (M / 2)^2},
   \end{equation}
   откуда $m = \sqrt{\left(1 - \sqrt{1 - (M / 2)^2}\right)^2 + (M / 2)^2} =
   \sqrt{2 - 2\sqrt{1 - (M / 2)^2}}$, или
   \begin{equation}
     2 - m^2 = \sqrt{2 + (2 - M^2)}.
   \end{equation}


Разбор задачи о представлении в виде суммы квадратов.

\subsubsection{Задача из Дейкстры}
Для любого заданного $r \geq 0$ найти все существенно различные формы представления $r$ в виде:
\begin{equation}
    r = x^2 + y^2, \qquad and \qquad x \geq y \geq 0.
\end{equation}
Для определённости пусть программа выдаёт список пар $(x, y)$, упорядоченный по возрастанию $x$.
Замечание --- пар с одним и тем же $x$ не может быть, и пусть $x$ начинается с 1 ((2, 0) будет,
(0, 2) --- нет).
\begin{minted}{haskell}
    go :: (Integer, Integer) -> Integer -> [(Integer, Integer)]
    go (x, y) r
        -- [1, 2, 3] == 1:[2,3] == 1:(2:[3]) == 1:2:3:[]
        | x * x > r      = []
        | x * x + y * y == r = (x, y) : (go (x + 1, 0) r)
        -- просто перебираем все варианты.
        | x * x + y * y < r  = go (x, y + 1) r
        | otherwise          = go (x + 1, 0) r

    f :: Integer -> [(Integer, Integer)]
    f r = go (1, 0) r

    main :: IO()
    main = print (f 4) -- [(2, 0)]
              -- 25    -> [(3,4), (4,3), (5, 0)]
              -- 625   -> [(7,24),(15,20),(20,15),(24,7),(25,0)]
\end{minted}

С какого $x$ начать и до какого идти? Можно начать с нуля и идти увеличивать $x$ на единицу до тех
пор, пока $2 x^2 < r$ --- и с этого $x$ начать (с меньшим мы не обеспечим верхнюю формулу). За счёт
этого избавимся от повторов вида (15, 20), (20, 15).

Решения может не быть как для конкретного $x$, так и вообще для данного $r$. Однако всегда можно
добиться выполнения двух условий, всегда есть такая пара чисел:
\begin{equation}
    x^2 + y^2 \leq r \qquad \text{and} \qquad x^2 + (y + 1)^2 > r.
\end{equation}
Будем следовать этим условиям --- пусть для нашей программы они будут инвариантом, то есть цикл
будет (стремиться) их выполнять.
\begin{minted}{haskell}
    f :: Integer -> [(Integer, Integer)]
    f r = go (x0 0 r, x0 0 r) r

    x0 x r
        | 2 * x * x < r = x0 (x + 1) r
        | otherwise     = x

    go :: (Integer, Integer) -> Integer -> [(Integer, Integer)]
    go (x, y) r
        -- порядок условий важен
        | x * x > r      = []
        | x * x + y * y > r  = go (x, y - 1) r
        -- ...после этих итераций будет выполнено x^2 + y^2 <= r
        -- и x^2 + (y + 1)^2 > r
        | x * x + y * y == r = (x, y) : (go (x + 1, y) r)
        -- x >= y, поэтому к y единицу можно не прибавлять
        | x * x + y * y < r  = go (x + 1, y) r
        -- теперь программа работает гораздо быстрее

    main :: IO()
    main = print (f (74*74*41*41*25*25)) -- [(55370,51840),(56248,50886),...]
    -- избавились от повторов за счёт x0
\end{minted}

Что изменилось? Программа стала гораздо быстрее и осталась такой же понятной(!).

\subsection{Контрольная, 1 час?}

\newpage

\begin{enumerate}
    \item Перевести числа в двоичную систему: 2, 8, 15, 48.
    \item Что делает код \mintinline{cpp}{template<typename A> A f(A& a) { return a++; }}?
    \item Написать функцию, выводящую на экран возрастающую последовательность чисел, делящихся на 7
        или на 11, начиная с 7 (7, 11, 14, 21, 22, ...), не используя операцию остатка от деления
        (\mintinline{cpp}{%}).
    \item Предложите численную схему для системы уравнений и приведите пример физической системы,
        движение которой описывается данными уравнениями:
        \begin{equation}
            \frac{dx}{dt} = y + 1, \quad \frac{dy}{dt} = t - x.
        \end{equation}
    \item Дано множество чисел $\{0,1,2,3,4\}$ с операцией сложения по модулю $5$. Докажите, что
        данное множество образует группу. Найдите все её подгруппы.
\end{enumerate}

\begin{enumerate}
    \item Перевести числа в десятичную систему: 10, 111, 1100, 100111.
    \item \mintinline{cpp}{template<typename T> T f(T* x) { (*x) *= 2; return (*x); }}
    \item Написать функцию, возвращающую true или false в зависимости от того, является или не
        является её аргумент степенью числа 8.
    \item
        \begin{equation}
            \frac{d^2x}{dt^2} + \frac{dx}{dt} + x = t \exp(-t^2).
        \end{equation}
    \item Дано множество чисел $\{1,2,3,4\}$ с операцией умножения по модулю $5$. Докажите, что
        данное множество образует группу. Найдите обратные элементы для всех элементов данной группы.
\end{enumerate}

\begin{enumerate}
    \item Перевести числа в двоичную систему: 1, 5, 16, 31.
    \item \mintinline{cpp}{template<int i> void f(int& j) { j += i; }}
    \item Написать функцию, возвращающую остаток от деления её аргумента на 5, не используя
        операцию остатка от деления (\mintinline{cpp}{%}).
    \item
        \begin{equation}
            \frac{dx}{dt} = y + t, \quad \frac{dy}{dt} = t^2/2 - x.
        \end{equation}
    \item Для квадрата $ABCD$ введена операция поворота на $90^\circ$ (обозначим эту операцию $a$),
        переводящая квадрат в себя. Для какого числа $p$ операция $a$, применённая $p$ раз (то есть
        $a^p$) не изменит положение вершин $ABCD$? Докажите, что множество ${a, a^2, a^3, ...}$
        (множество всех возможных степеней, без повторeния элементов) образует группу. Найдите её подгруппы.
\end{enumerate}

\newpage

\subsubsection{ООП --- инкапсуляция и наследование}
Классы. Инкапсуляция --- сокрытие методов и их реализации внутри типа. Пользовательский интерфейс.
public and private. Конструкторы. Деструкторы. В чём разница со структурами?
\begin{minted}{cpp}
    #include <iostream>
    using namespace std;

    struct S {
        int x;
        int y;
    };

    int dot(S a, S b) {
        return a.x * b.x + a.y * b.y;
    }

    class C {
        public:
            int x;
            int y;
    };

    int dot(C a, C b) { // перегрузка функции
        return a.x * b.x + a.y * b.y;
    }

    int main() {
        S s;
        s.x = 1;
        s.y = 2;
        cout << dot(s, s) << "\n"; // 5
        C c;
        c.x = 1;
        c.y = 2;
        cout << dot(c, c) << "\n"; // 5
        return 0;
    }
\end{minted}
--- здесь классы --- те же структуры, только пришлось писать public. Инкапсуляция:
\begin{minted}{cpp}
#include <iostream>

class C {
    public:
        int x;
        int y;
        int norm(); // описание функции
};

int C::norm() { // определение функции
    return x * x + y * y; // &this
}

int main() {
    C c;
    c.x = 1;
    c.y = 2;
    std::cout << c.norm() << "\n"; // 5; инкапсуляция
    return 0;
}
\end{minted}
В чём смысл? Технически полный аналог функции, принимающей ссылку на объект, для которого она
вызвана. Зачем нужно? Иногда таким образом структурированный код легче воспринимать. Чётко видно,
какие функции к кому относятся (в случае шаблонов это неочевидно, пользователь может вызвать их не
для того, для чего они написаны). (Наследование...). Можем сделать часть внутренних переменных и
функций --- private. Ещё --- создание типов, ни чем не отличающихся от встроенных: конструкторы и
деструкторы:
\begin{minted}{cpp}
    #include <iostream>
    using namespace std;

    class C {
        private:
            int x;
            int y;
        public:
            C(); // default constructor
            C(int); // constructor with parameter
            ~C(); // destructor
            void print();
    };

    C::C() {
        x = 1;
        y = 2;
    }

    C::C(int z) {
        x = z;
        y = z;
        cout << "hi!\n";
    }

    C::~C() {
        cout << "bye!\n";
    }

    void C::print() { // определение функции
        cout << x << "\t" << y << "\n";
    }

    int main() {
        C c; // -> default constructor
        {
            C d(5); // hi!
            d.print(); // 5 5
            // bye!
        }
        c.print(); // 1 2
        // bye!
        return 0;
    }
\end{minted}
Обращаемся --- как с обычными, встроенными типами (int,...).

\subsection{Наследование}

Вернёмся к возведению в степень через умножение. Какой тип может принимать соответствующая функция?
int, float, double... Все эти типы обладают общим свойством --- переменные
этих типов можно умножать.

Две проблемы. Первая. В C++ мы можем написать функцию-шаблон, но в описании функции совсем не видно будет того общего
свойства, которое нам нужно (в коде, конечно, будет видно использование оператора $*$). Вторая ---
оперирование разнородными элементами (дальше будет подробнее), например, списками из int, double,
float вместе. Другой пример - посылаем сообщения. Разные типы данных могут быть посланы,
принимающие "функции" могут делать разные вещи. Что делать с этой разнородностью?

Наследование (inheritance) придумали для решения этих проблем (в основном второй). Как оно
реализовано в C++. Пусть есть набор фигур --- кругов и квадратов. Общее --- координаты и размер
стороны (или радиус в случае круга).
\begin{minted}{cpp}
#include <iostream>

// base class
class shape {
public:
    double x, y, r;
};

// derived class
class circle: public shape
{};

// derived class
class square: public shape
{};

int main() {
    square s;
    s.x = 1;
    circle c;
    c.r = 1;
    std::cout << s.x - c.r << "\n";
    return 0;
}
\end{minted}

Ввели два довольно бесполезных типа --- но они разные, и это проверяет компилятор, если случайно
смешать --- код не скомпилируется. А что делать с методами --- площадь вычисляется по-разному для
circle и square (отличие от шаблонов - там, наоборот, один и тот же код).
\begin{minted}{cpp}
#include <iostream>
#include <cmath>

// base class
class shape {
public:
    // private - not available for derived classes
    // protected - available for derived but as private for others
    double x, y, r;
    // derived class do not inherit constructors
    // and destructors in C++03 and does in C++11 standart
    shape() {
        x = 1;
        y = 2;
        r = 3;
    }
    // virtual means what derived classes can provide its own function
    virtual double area() {
        return 0;
    }
};

// derived class
class circle: public shape {
public: // area was public, but should define this again
    double area() {
        return M_PI * r * r;
    }
};

// derived class
class square: public shape { // , public polygon // multiple inheritance
public:
    double area() {
        return r * r;
    }
};

int main() {
    square s;
    std::cout << s.x << "\n"; // 1, constr. can be inherited
    s.r = 1;
    circle c;
    c.r = 1;
    std::cout << s.area() << "\t" << c.area() << "\n";
    return 0;
}
\end{minted}
Однако мы хотели большего --- мы хотели бы не писать шаблонных функций, а потом конкретизировать их
каждый раз в square и circle, а хотели бы писать функции для shape. Основное свойство для этого ---
указатель на производный (derived) класс совместим по типу с указателями на базовый класс.
\begin{minted}{cpp}
void print_area(shape* p) {
    std::cout << "Area of the shape is " << p -> area() << "\n";
}

int main() {
    square s;
    s.r = 1;
    circle c;
    c.r = 1;
    shape* p1;
    shape* p2;
    p1 = &s; // this is ok!
    p2 = &c;
    print_area(p1);
    print_area(p2);
    return 0;
}
\end{minted}
В этом смысл наследования, хотя выглядит это часто более громоздко, чем в других языках, с выводом
типов, например.

Идеи о классах, шаблонах и наследовании появились в Си++ для удобства, из практических соображений.
Но на них можно посмотреть и со стороны математики --- как на применение абстракций в
программировании. То есть классы, шаблоны, наследование --- всё это нужно только тогда, когда
возможна, например, реализация алгоритма в абстрактной форме.

Очень много возможностей. Виртуальные, невиртуальные, члены с данными, private, public и т. д. Что
нам нужно было для сортировки --- только сравнение. Для возведение в степень --- только умножение.
У треугольника три стороны (характеризуется тремя числами), у квадрата --- четыре, и делать три из
них через наследование --- странно. Круг --- один параметр и т. п. Общее --- не члены с данными, а
функции --- все имеют площадь и периметр. На самом деле наследование лучше ограничить случаем
базового класса без членов с данными, а только с виртуальными функциями, которые обязательно должны
реализовывать наследники (это аналог типажей (traits) в Rust, например).

\begin{minted}{cpp}
#include <iostream>
#include <cmath>
using namespace std;

class shape {
    public: // или protected,,,
        virtual double perimeter() = 0; // это значит, что наследник
            // обязательно должен предложить своё определение функции,
            // свою реализацию.
        virtual double area() = 0; // мог быть шаблон и T вместо double
};

class triangle: public shape {
    public:
        double x, y, z;
        double perimeter() {
            return x + y + z;
        }
        double area() {
            return 1; // smth
        }
};

class circle: public shape {
    public:
        double r;
        double perimeter() {
            return 2 * M_PI * r;
        }
        double area() {
            return M_PI * r * r; // smth
        }
};

int main() {
    triangle t;
    t.x = 1;
    t.y = 1;
    t.z = 1;
    circle c1, c2;
    c1.r = 1;
    c2.r = 2;
    //shape* p = new shape[3]; // как это было бы размещено в памяти?
    shape** p = new shape*[3];
    p[0] = &t;
    p[1] = &c1;
    p[2] = &c2;
    for (int i = 0; i < 3; ++i) {
        cout << p[i] -> perimeter() << "\n"; // как это реализовано? как
        // компилятор решает, какую функцию вызвать? dynamic dispatch, vtable
        // дополнительные расходя памяти на каждый объёкт класса!
    }
    return 0;
}
\end{minted}

\subsubsection{Числа с точки зрения наследования}

(Система типов в Haskell так сделана). Bool, $\&\&$. Num - даёт операцию $+$. И натуральные числа можно
складывать между собой, рациональные --- между собой, комплексные и т. д. Fractional, $/$. Ord,
$<,\; >$. Eq, $==$, Real? (sqrt). Распределить наследование ($+,\; >,\; /,\; \sqrt{}$) для натуральных чисел, рациональных
чисел, иррациональных чисел, комплексных чисел. (Сплошная математика).

\subsection{Стандартная библиотека. Std vector.}

vector --- как массив, но несколько удобнее. Осторожнее с указателями на элементы!
\begin{minted}{cpp}
// Vector initialization
#include <vector>
#include <iostream>
using namespace std;

int main() {
    vector<int> v(10); // 10 elements
    //vector<int> v(10, 2);
    for (auto& x: v) { // C++11
        static int i = 0;
        x = i++;
    }
    v[2] = 25; // 0 1 25 3 4 ...
    // === push_back, iterators ===
    for (int i = 0; i < 6; i++) {
        v.pop_back(); // 0 1 25 3
    }
    v.push_back(49); // 0 1 25 3 49
    // без using... -> std::vector<int>::iterator
    for (vector<int>::iterator it = v.begin(); it != v.end(); ++it) {
        cout << *it << " "; // 0 1 25 3 49
    }
    cout << "\n";
    // === operator = ; size() ===
    v = vector<int>(3);
    cout << v.size() << "\t" << v.capacity() << "\n"; // 3 3
    v.reserve(10); // увеличивает емкость до значения, большего или равного указанному
    cout << v.size() << "\t" << v.capacity() << "\n"; // 3 10
    for ( int i = 0; i < 40; ++i) {
        size_t c = v.capacity();
        v.push_back(1);
        if (c != v.capacity()) {
            cout << v.capacity() << "\n"; // 20 40 80
        }
    }
    // [], resize, const iterators, front, back, data...
}
\end{minted}

\subsection{Binary trees}

Двоичное дерево --- иерархическая структура, в которой каждый узел содержит (хранит) некоторое
значение и имеет не более двух потомков (поддеревьев, тоже деревьев).
\begin{minted}{haskell}
data Tree a = Node a (Tree a) (Tree a) | Empty
              deriving (Show)

tree1 = Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty)
-- где здесь шаблоны?
tree2 = Node 4 (Empty) (Node 5 Empty Empty)
tree3 = Node 15 (tree1) (tree2)

insertToLeft :: Int -> Tree Int -> Tree Int
insertToLeft a Empty = Node a (Empty) (Empty)
insertToLeft a (Node b t1 t2) = Node b (insertToLeft a t1) t2

main = print (insertToLeft 137 tree3)

{- Node 15
       (Node 1
           (Node 2
               (Node 137 Empty Empty)
               Empty)
           (Node 3 Empty Empty))
       (Node 4
           Empty
           (Node 5 Empty Empty))
-}
\end{minted}
Вставка занимает в среднем логарифмическое (по сравнению с числом узлов) время.

Двоичное дерево поиска (сортированное), двоичная куча --- двоичное дерево, в котором для любого
узла X значения, хранимые во {\bf всех} в узлах левого поддерева, меньше значения, хранимого в узле
X, а значения, хранимые в узлах правого поддерева --- больше. Примеры, рисунки. Задание --- дерево
для толкового (например) словаря. Сколько времени занимает поиск, вставка, удаление? В среднем
$O(log n)$, в худшем случае --- $O(n)$, но маловероятно; $n$ --- число узлов. Потребление памяти
--- $O(n)$.

Балансировка деревьев применяется для того, чтобы все поддеревья имели примерно равную глубину. Для
балансировки может применяться поворот:
\begin{minted}{haskell}
    -- до поворота
    Node 4
        (Node 2
            (Node 1
                Empty
                Empty)
            (Node 3
                Empty
                Empty))
        Empty)
    -- после поворота
    Node 2
        (Node 1
            Empty
            Empty)
        (Node 4
            (Node 3
                Empty
                Empty)
            Empty))
        Empty)
\end{minted}
Поворот не меняет упорядоченность, но изменяет длину поддеревьев на $\pm 1$. Красно-чёрные деревья,
АВЛ (советское, 1962 г., создали первого компьютерного шахматного чемпиона) деревья ---
дополнительные операции при вставке элементов, но зато деревья --- сбалансированные (АВЛ ---
поддеревья различаются по высоте (глубине) не более, чем на 1).


\subsection{Стандартная библиотека. Std set. Std map.}

\subsection{SO3}

\section{Второй курс}

\subsection{О линейной алгебре и теории групп}

Рассмотрим задачу из книги~\cite{Kirillov08} (Example 1.1), кажущуюся на первый взгляд чисто
практической, но имеющую очень красивое математическое решение. Пусть у нас есть комплексные числа $a_1, ...,
a_n$, и есть преобразование $A$, заменяющее $a_1$ на $(a_n + a_2) / 2$, $a_2$ на $(a_1 + a_3) /
2$ и т.~д. Если много раз применить преобразование $A$, что в итоге получится?

Для ответа нужно найти собственные значения оператора $A$, однако явное вычисление корней
характеристического многочлена --- непростая задача. Тем не менее можно заметить, что задача
обладает вращательной симметрией. Введём оператор $B$ такой, что он делает "вращение" на $2 \pi
/ n$, а именно посылает числа $a_1, a_2, ..., a_n$ в ячейки $a_2, a_3, ..., a_1$. Очевидно, что
$B A B^{-1} = A$, то есть $A$ и $B$ коммутируют.

Оператор $B$ порождает группу, изоморфную группе $\mathbb Z_n$ (группа целых чисел ${0, 1, ..., n -
1}$ со сложением по модулю $n$). Как можно использовать эту группу для поиска собственных
векторов оператора $A$? Можно использовать хорошо известный из линейной алгебры результат: если
$A$ и $B$ коммутируют в векторном пространстве $V$, и $V_\lambda$ есть линейное
подпространство, соответствующее некоторому собственному числу $\lambda$ оператора $B$, то $A
V_\lambda \subset V_\lambda$ (легко доказать "от противного"). Следовательно, если оператор $B$
диагонализуем так, что исходное векторное пространство раскладывается в прямую сумму $V =
\bigoplus V_\lambda$, тогда $A$ сохраняет эту декомпозицию и задача сводится к диагонализации
$A$ отдельно в каждом из $V_\lambda$, что существенно проще.

\textit{Задача для решения у доски.} Можно заметить, что $B^n = \mathrm{id}$ (единичный оператор), следовательно, все
собственные значения $B$ есть $n$-ые корни мнимой единицы. Показать, что все собственные значения
различны, найти их, найти собственные вектора (они же собственные вектора $A$!) и найти собственные
значения $A$. Что будет с $(a_1, ..., a_n)$ при многократном применении $A$?

\subsection{Повторение}

int main. const. static. Структуры. Шаблоны. Шаблоны с числовым параметром (non-type template parameter). Классы.
Наследование. 
Структурирование кода. Функции, передача функций в качестве аргумента. Top-down method. 

Стандартная библиотека. Vector, List, Map. Размещение в памяти. $O(N)$ нотация и стоимость операций
вставки, удаления. Сбалансированные деревья. Сортировка быстрая, слиянием.

потоки. OpenMP, MPI, OpenCL

\subsection{Интегрирование методом Монте Карло}

Феномен Пиаже (как комментарий к задаче Кириллова). А какик собственные вектора у оператора,
который локально заменяет $a_2$ на $3 a_1 + a_4$, и т. д.? Наше пространство симметрично
относительно трансляций, оно одно и тоже в разных точках, поэтому симметрия в физических задачах
оказывается так важна.

\clearpage

\begin{figure}
	\includegraphics[width=1\linewidth]{dots-for-monte-carlo.png}
    \caption{\label{dots-for-monte-carlo}Заполнение фигуры случайными точками, имеющими равномерное
    распределение на плоскости (слева) и точками, находящимися в узлах регулярной прямоугольной
    сетки (справа).}
\end{figure}

\subsubsection{Вычисление интегралов методом Монте Карло}

Как мы увидим, не всегда для вычисления интегралов достаточно использовать известный метод
прямоугольников или метод трапеций. И основная проблема здесь --- невысокая точность при вычислении
интегралов в пространстве высокой размерности. Например, попробуем оценить точность метода
прямоугольников при вычислении площади под прямой $y = x$ на отрезке $x \in [0, 1]$. Если для
вычисления мы возьмём $n$ прямоугольников, то ошибка вычисления интеграла, как легко вычислить,
будет порядка $O(1/n)$ ($n$ <<краешков>> прямоугольников площадью $\sim 1/n^2$ каждый попадают над
или под кривую, для которой мы вычисляем площадь). Если мы захотим вычислить методом
прямоугольников площадь под косо располозенной плоскостью, над основанием, разбитым на $n \times n$
прямоугольников (по осям $x$ и $y$), то ошибка снова будет порядка $O(1/n)$. Однако при этом
количество прямоугольников уже $\sim n^2$. Экстраполирую наши выводы на $D$-мерный интеграл, можно
заметить, что общее число прямоугольников ($\sim n^D$), и общее число вызовов интегрируемой
функции, растёт экспоненциально с ростом $D$ при сохранении определённого уровня точности ($\sim
1/n$). Это делает метод прямоугольников неприменимым в пространствах большой размерности. Наверное,
в этот момент стоит вспомнить, что в физике (и не только) встречаются задачи и в бесконечномерном
пространстве.

Метод Монте-Карло, который мы рассмотрим --- это настоящее математическое чудо, поскольку не
теребует экспоненциального роста числа точек в зависимости от размерности, при том, что он, на
первый взгляд, очень похож на метод прямоугольников. Суть простого (геометрического) метода
Монте-Карло состоит в следующем.  <<Накидываем>> (случайно! равномерно!) точки на плоскость, на
которой проведена кривая, площадь под которой мы хотим вычислить. Считаем те точки, что попали под
кривую. Отношение их к общему числу точек есть отношение площади области, в которой генерируем
точки, к площади под кривой. Если бы мы распределяли точки не случайным образом, а, скажем, ставили
бы их в узлах прямоугольной сетки (см. рисунок~\ref{dots-for-monte-carlo}), и использовали в методе
Монте-Карло, то получили бы те же проблемы, что и в методе прямоугольников.  <<Случайность>> точек
позволяет избавиться от этих проблем --- как мы покажем позже, ошибка метода Монте-Карло зависит то
количества точек, $N$, как $O(1/\sqrt{N})$. Стоит отметить, что в эту формулу размерность
пространства вообще никак не входит.  Таким образом, в среднем для уменьшения ошибки вдвое нам
нужно увеличить число точек в 4 раза, в то время как в случае использования метода прямоугольников
нам потребовалось бы вдвое увеличить разбиение по каждой оси, при этом общее число точек выросло бы
в $2^D$ раз.

\textit{Задача о вычислении объёма многомерного шара}. Требуется написать программу, вычисляющую с
помощью геометрического метода Монте-Карло объём $V$ шара единичного радиуса в пространстве
размерности $D$ и построить график $V(D)$ вплоть до $D = 10$. Можно заметить, что ошибка метода
(обозначим её $\varepsilon$), то есть разница вычисленного и реального объёмов, есть случайная
величина. Для $D = 2$ и $D = 3$ требуется построить зависимость среднеквадратичного отклонения
$\sigma$ для случайной величины $\varepsilon$ от числа точек, $N$, и показать, что
$\sigma_\varepsilon \sim 1 / \sqrt{N}$.

Есть не-геометрическая вариация метода Монте-Карло для вычисления интегралов, ещё больше похожая на
метод прямоугольников, но, тем не менее, обладающая той же точностью, что и геометрический метод. А
именно, интеграл от функции $f(x)$ вычисляется через сумму её значений в случайных точках, имеющих
равномерное распределение:
\begin{equation}
    \int_a^b f(x) \, dx \approx \frac{(b - a)}{N} \sum_{i=1}^N f(x_i).
\end{equation}
В методе прямоугольников используется та же формула, но точки распределены на отрезке $[a, b]$ с
постоянным шагом.

Интересно, что метод Монте-Карло в завуалированном виде встречается и в чистой математике. Так,
известный критерий Вейля говорит, что распределение чисел $x_j$ равномерно на $(0, 1)$ если и
только если для всех натуральных $\ell$ выполнено
\begin{equation}
    \lim_{N \to \infty} \frac{1}{N} \sum_{j = 1}^N \exp(2 \pi i \ell x_j) = 0.
\end{equation}
Видно, что этот критерий в определённом смысле эквивалентен утверждению, что <<интеграл от функции
$\sin x$ на её периоде равен нулю>>.

\subsection{Методы генерации случайных чисел с заданным распределением}

\subsubsection{Rejection sampling (выборка с отклонением, или с отбраковкой)}

Этот метод является очень простым, и в то же время имеет много общего с геометрическим методом
Монте-Карло для вычисления интегралов. Суть его простейшего варианта в следующем. Предположим, что
мы умеем генерировать числа, равномерно распределённые на отрезке $(a, b)$, но нам нужен генератор
псевдослучайных чисел, имеющих распределение $dN/dx = f(x)$ на этом отрезке. Таким образом,
вероятность попадания числа в интервал $(x, x + \Delta x)$ для $\Delta x \to 0$, должна быть
пропорциональна $f(x)$.  Считаем, что $f(x)$ ограничена, то есть $f(x) < c$ [также очевидно, что
$f(x)$ не может быть меньше нуля]. Тогда мы можем равномерно засеять область $x \in (a, b)$, $y \in
(0, c)$ точками, и отбраковать (отклонить) те из них, которые окажутся над кривой $f(x)$.
Оставшиеся точки будут иметь нужное нам распределение!

Для доказательства найдём число точек, попадающих в среднем в интервал $(x, x + \Delta x)$ при
малом $\Delta x$. Поскольку распределение точек на интервале $(a, b)$ до отбраковки равномерное, то
их число (опять же, до отбраковки) в интервале $(x, x + \Delta x)$, будет пропорционально $\Delta
x$ и не будет зависеть от $x$. После отбраковки число точек уменьшится в $c / f(x)$ раз, то есть
число оставшихся в интервале $(x, x + \Delta x)$ точек пропорционально $f(x)$, что и требовалось
доказать. Остаётся только отметить, что при программировании данного метода отбраковку точки можно
производить сразу же по критерию $y_j > f(x_j)$, без сохранения всех точек в какие-либо временные
структуры.

\clearpage

\subsubsection{Через обращение $N(x)$}

\subsubsection{Метрополис. Метод имитации отжига.}

сначала плоская (альтернативный метод), потом любая p.

Пусть целевое распределение пропорционально функции $f(x)$, а шаги генерируются с распределением
$g(x - y)$, где $x$ --- текущая точка, $y$ --- следующая. Тогда на каждой итерации алгоритм
выглядит так:
\begin{enumerate}
    \item qwe
    \item qwz
\end{enumerate}

Интегрирование для неравномерного распределения. Пусть нам нужно вычислить интеграл от
произведения, $a(x) p(x)$:
\begin{equation}
    \int_a^b a(x) p(x) \, dx \approx \frac{\sum_{i=1}^N f(x_i)}{N},
\end{equation}
где $p$ --- плотность вероятности используемого случайного распределения, для равномерного
распределения --- константа. Если нужно вычислить интеграл от $f$ (для узкой $f$, например), то
можно сгенерировать распределение с плотностью вероятности $f$. Такой метод даст
меньшую ошибку.

Вильсон (не тот, что камера Вильсона). Интегралы по траекториям.

\subsection{Задача о пьяном человеке, доска Гальтона и Центральная предельная теорема}

Синяя тетрадь, оранжевые наклейки.

\subsection{Дз --- несимметричная доска Гальтона + решение уравнения Шредингера (нахождение уровней
энергии нижних трёх состояний, формы волновых функций? Найти $\Omega$ для $\alpha = 10^{-4}$,
должно получиться около $0.012$.}

Как ошибка в Монте Карло интегрировании зависит от числа точек --- теперь можем ответить.
Рассмотрим геометрический метод Монте Карло. Очевидно, что при фиксированном общем числе точек
число точек "под кривой" есть сумма большого числа случайных величин ($\pm 1$ с некоторой вероятностью, что
соответствует попаданию или непопаданию под кривую). Применив ЦПТ, получим, что число точек внутри
стремится к вероятности попасть под кривую, умноженной на общее число точек (закон больших чисел), а квадрат
среднеквадратичного отклонения (дисперсия) растет пропорционально числу частиц. Ошибка
интегрирования, равная среднеквадратичному отклонению, деленному на число точек $N$,
пропорциональна $1 / \sqrt{N}$.

На прошлой лекции --- уравнение теплопроводности. Для $w_{-1} = w_1 = 1/2$:
\begin{equation}
    \frac{\partial P}{\partial t} = \frac{1}{2} \frac{\partial^2 P}{\partial x^2},
\end{equation}
для произвольной $w$ вместо $1/2$ будет стоять $\sum_l l^2 w_l / 2$, что в случае $w_{-1} = w_1 =
w_0 = 1/3$ даст $1/3$. Сравним с уравнением Шредингера для гармонического осциллятора:
\begin{equation}
    i \hbar \frac{\partial \Psi}{\partial t} = - \frac{\hbar^2}{2 m} \frac{\partial^2 \Psi}{\partial x^2} + V(x) \Psi,
\end{equation}
где $V(x) = k x^2 / 2$, $k$ --- жесткость пружины.
Что нам от него нужно? Правая его часть --- оператор энергии, его собственные значения ---
дискретны. (Красивая математическая идея Гейзенберга о неизмеримости и некоммутативности). Уровни
энергии --- атомные уровни, спектр излучения. Для собственных векторов оператора энергии $\Psi
\propto \exp(-i E_k / \hbar)$, $E_k = \{\hbar \Omega / 2, 3 \hbar \Omega / 2, ...\}$, где $\Omega =
\sqrt{k / m}$ --- частота осциллятора в классической задаче.

Предположим, что мы не можем по каким-то причинам решать напрямую уравнение Шредингера (например,
конечно-разностными методами), но хотим найти уровни энергии (хотя бы самые нижние). Заменой $\tau
= i t$ при условии $\hbar / 2 m = 1 / 3$, $k / 2 \hbar = \alpha$ из Шредингера получим
\begin{equation}
    \frac{\partial \Psi}{\partial t} = \frac{1}{3} \frac{\partial^2 \Psi}{\partial x^2} - \alpha
    x^2 \Psi,
\end{equation}
где $Omega = 4 \alpha / 3$.
Очень похоже на уравнение теплопроводности.
Собственные функции правой части --- те же, что и раньше, собственные числа те же, но экспоненты
станут действительными.

Как построить "доску Гальтона" для этого уравнения? Например, можно ввести веса частиц и при
переходе строго вниз умножать вес частицы на $(1 - V(x) / w_0)$ ("пылесос"). Экспоненты можно найти
из корреляции, например:
\begin{eqnarray}
    \Psi(x, 0) = \sum_l C_l \psi_l(x), //
    \int_{-\infty}^\infty \Psi(0) \Psi(t) = \sum_l C_l^2 \exp(-E_t).
\end{eqnarray}
($\psi$ ортогональны в силу эрмитовости $\bar H$, пусть они заодно и нормированы. По наклону в
логарифмическом масштабе можем найти самую "медленную" экспоненту...

\subsection{Оптимизация в спп}

Компиляторы транслируют программу из языка программироавния в машинные команды. При этом прямого
соответствия команд нет, и у компилятора есть определённая свобода. Основные компиляторы: msvc,
icc, gcc. Флаги компиляции --- способ управления компилятором. msvc --- debug, release.
\begin{minted}{bash}
    g++ -O0 main.cpp
\end{minted}
--- скомпилировать без оптимизаций. O1, O2, O3 --- включают всё больше и больше флагов оптимизации.

Что может замедлять? Вызов функции (накладные расходы), вычисление некоторых функций (например,
exp), простые операции имеют разную сложность (умножение, деление, сложение). Операции со степенями
двойки могут быть записаны через битовые операции, что может быть быстрее.

Пример. Если мы будем решать уравнения Максвелла (двумерные), то можем написать:
\begin{minted}{cpp}
for (size_t i = 0; i < nx; ++i) {
    for (size_t j = 0; j < ny; ++j) {
        # operation in a big loop...
        bx[i][j] -= 0.5 * dt * (ez[i][j] - ez[i][j - 1]) / dy;
    }
}
\end{minted}
Очевидно, что можно уменьшить число операций в цикле, если вычислить произведение констант вне
цикла:
\begin{minted}{cpp}
dtdy05 = 0.5 * dt / dy;
...
    bx[i][j] -= dtdy05 * (ez[i][j] - ez[i][j - 1]);
\end{minted}
Экономим одно деление и одно умножение на каждом шаге. Очевидное улучшение, но даже при O3
компилятор не делает его. Дело в том, что иногда нужна вся возможная точность double (например,
хотим знать, внутри многоугольника точка или нет). А от порядка умножений может зависеть результат
(поскольку double ограничен): очень большое на очень маленькое на очень маленькое может дать при
умножении с конца ноль. Мы можем нарушить стандарт вычислений (если у нас нет таких ситуаций) и
включить флаг ffast-math. Тогда компилятор сделает упрощение.

Блокировщики оптимизации. https://habrahabr.ru/post/309796/
Компиляторы, как правило, делают только безопасные оптимизации, и иногда их нужно заставлять делать
оптимизации, как в примере выше, или подсказывать им.
\begin{minted}{cpp}
// v is an object of some class
for (int i = 0; i < v.length(); ++i) {
    v.x += f() + f() + f();
}
\end{minted}
Три вызова функции (доп. накладные расходы) и два сложения хочется заменить на одно умножение
\mintinline{cpp}{v.x += 3 * f();}, но это можно сделать, в общем случае, только если f --- чистая
функция. Если же она меняет глобальные переменные или пишет что-то на экран --- результат будет
совсем другой. Иногда компилятор не может определить, чистая ли это функция и можно ли сделать
такую замену, например \mintinline{cpp}{v.x += v.f() + v.f() + v.f();}. Сможет ли определить
компилятор, можно ли вынести вызов length из цикла? Не всегда сможет, поскольку v меняется в цикле,
лучше явно подсказать:
\begin{minted}{cpp}
int n = v.length();
for (int i = 0; i < n; ++i) {
    v.x += 3 * f();
}
\end{minted}
Ещё пример:
\begin{minted}{cpp}
    void f1(int* xp, int* yp) {
        *xp += *yp;
        *xp += *yp;
    }
    void f2(int* xp, int* yp) {
        *xp += 2 * (*yp);
    }
\end{minted}
В общем случае компилятор не может свести f1 к f2, так как случай, при котором xp и yp ссылаются на
одну и ту же ячейку, не исключён.

Вернёмся к циклам. Если тело цикла маленькое, накладные расходы на обслуживание цикла могут быть
большими:
\begin{minted}{cpp}
dtdy05 = 0.5 * dt / dy;
for (size_t i = 0; i < nx; ++i) { // накладные расходы
    for (size_t j = 0; j < ny; ++j) { // накладные расходы
        bx[i][j] -= dtdy05 * (ez[i][j] - ez[i][j - 1]);
    }
}
\end{minted}
Можно сделать две (несколько) итерации за шаг цикла:
\begin{minted}{cpp}
dtdy05 = 0.5 * dt / dy;
for (size_t i = 0; i < nx; ++i) {
    for (size_t j = 0; j < ny; j += 2) {
        bx[i][j] -= dtdy05 * (ez[i][j] - ez[i][j - 1]);
        bx[i][j + 1] -= dtdy05 * (ez[i][j + 1] - ez[i][j]);
    }
}
...// обработка "хвоста"
\end{minted}
К счастью, компилятор, как правило,сам догадывается сделать такую оптимизацию (развёртывание
цикла, O3?), если его ничто не блокирует.

Введение аккумуляторов --- для уменьшения числа обращений к памяти.
\begin{minted}{cpp}
void sum(vec* v, float* res) {
    long i, len = vec_len(v);
    float acc = 1; // аккумулятор
    for (i = 0; i < len; i++) {
        acc += v->data[i];
    }
    *res = acc;
}
\end{minted}
Если бы мы вместо acc использовали res, то получили бы лишние обращения чтение-запись к памяти,
которые компилятор не смог бы убрать, res потенциально может ссылаться на внутренности v.

Векторизация...

Конвейер. Даже простейшие операции (умножение, сложение) в процессоре разбиты на шаги. И эти шаги
(чтение памяти, сложение чисел, запись в память) выполняют разные функциональные блоки. Выполнение
одной инструкции может занимать несколько тактов, однако, как правило, можно организовать конвейер:
один шаг от одной инструкции делается на одном функциональном блоке, другой шаг другой инструкции
--- в это же время --- на другом. Однако эффективно организовать конвейер можно только при
независимых данных. Пример зависимых данных:
\begin{minted}{cpp}
    // in a loop
    acc = acc * v[i];
\end{minted}
мы не можем начать второе умножение, если первое не завершилось ещё. Конечно, компилятор может
здесь сам улучшить код, но не всегда может это сделать (если acc - double, например). Если
производительность критична --- можно поэкспериментировать.
\begin{minted}{cpp}
    // in a loop
    //... i += 2 ...
    acc0 = acc0 * v[i];
    acc1 = acc1 * v[i + 1];
    //...
    acc = acc0 * acc1;
\end{minted}

Что происходит с if в конвейере? Для эффективности конвейер должен быть задействован, и часто он не
может ждать, пока проверится условие. Поэтому процессор использует предсказатель переходов ---
пытается угадать, какая ветка if будет нужна с большей вероятностью, и эту ветку отправляет на
конвейер. В случае удачи конвейер задействован полностью, в случае, если предсказатель переходов не
угадал --- результаты многих шагов конвейера (10-20, например), приходится отбросить и считать всё
заново. Если вычисление предиката просты, то можно заменить передачу управления передачей данных.
\begin{minted}{cpp}
void minmax1(int a[], int b[], int n) {
    for (int i = 0; i < n; i++) {
        if (a[i] > b[i]) {
            int t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}

void minmax2(int a[], int b[], int n) {
    for (int i = 0; i < n; i++) {
        int min = a[i] < b[i] ? a[i] : b[i]; // a < b, тогда a
        int max = a[i] < b[i] ?  b[i] : a[i]; // дважды проверяем условие,
            // больше промежуточных
            // переменных, но нет проблем с конвейером
        a[i] = min;
        b[i] = max;
    }
}
\end{minted}
Второй вариант работает быстрее (например, в 10 раз).

Зачем ещё нужна оптимизация? Байка про оптимизацию и раскачку колебаний на Аполлоне 11.

Кэш. Чтение из произвольного места в памяти --- довольно долгая операция. Однако быстро можно
получить не одну ячейку, а сразу кусочек данных, которые лежат в памяти рядом, и поместить их в кэш
--- быструю, но малоёмкую память процессора. Пример.
\begin{minted}{cpp}
for (size_t i = 0; i < nx; ++i) {
    for (size_t j = 0; j < ny; ++j) {
        # operation in a big loop...
        bx[i][j] -= 0.5 * dt * (ez[i][j] - ez[i][j - 1]) / dy;
    }
}
\end{minted}
Перемена мест циклов может изменить производительность.

Другой пример.
\begin{minted}{cpp}
// -std=c++11
#include <iostream>
#include <list>
#include <cstdlib>
#include <chrono>
using namespace std;

// sum or fold function
template<typename D> D sum(const list<D>& data, D res0) {
    D res = res0;
    for (auto x: data) { // const iterator
        res += x;
    }
    return res;
}

int main() {
    const long n = 300000; // size_t?
    list<double> xs;
    srand(123);
    // initialization
    for (long i = 0; i < n; ++i) {
        xs.push_back(static_cast<double>(rand()) / RAND_MAX); // rand is not the best choise
    }
    // lets measure sum time
    auto t0 = chrono::high_resolution_clock::now();
    double s = sum(xs, 0.0); // we could not write <double> here, but should
                              // write (int) 0 as double 0.0
    auto t1 = chrono::high_resolution_clock::now();
    cout << "sum of unsorted = " << s << "\n"; // approximately n / 2
    double t = 1e-9 * chrono::duration_cast<chrono::nanoseconds>(t1 - t0).count();
    cout << "sum of unsorted takes = " << t << " s\n";
    cout << "time per element = " << t / n << " s\n";
    xs.sort();
    // lets measure sum time
    t0 = chrono::high_resolution_clock::now();
    s = sum(xs, 0.0);
    t1 = chrono::high_resolution_clock::now();
    cout << "sum of sorted = " << s << "\n"; // approximately n / 2
    t = 1e-9 * chrono::duration_cast<chrono::nanoseconds>(t1 - t0).count();
    cout << "sum of sorted takes = " << t << " s\n";
    cout << "time per element = " << t / n << " s\n";
    return 0;
}
\end{minted}
Компиляция:
\begin{minted}{bash}
    g++ -std=c++11 -O0 cache.cpp
    g++ -std=c++11 -O3 cache.cpp
\end{minted}
Результаты на графике. O3 уменьшает время с 17 до 3 (для несортированного списка), а сортированный
независимо от оптимизации при больших размерах даёт время около 100 нс на элемент. Чем выделено
число 100000? 64 бита на double плюс 2 указателя тоже по 8 байт, получается около 2 МБ. Кэш верхнего
уровня (L3) - 8 MB. Замечание: могли бы написать свою сортировку, которая перевыделяла бы память
под элементы списка, и всё было бы быстро. list sort видимо, манипулирует только указателями, не
перезаписывая сами элементы списка (для производительности с большими элементами списка, или для
безопасности).
\begin{figure}[h]
  \centering
  \includegraphics[width=8.3cm]{cache.png}
    \caption{\label{fig:stereo}Time of {\it sum} function.}
\end{figure}

\subsection{Python}

{Как пользоваться}

Программы --- Стандартные --- Командная строка
\begin{minted}{bash}
    set PATH=%PATH%;C:\Anaconda3
    python filename.py # jupyter-notebook
    # or
    set PATH=%PATH%;C:\Anaconda3\Scripts
    jupyter-notebook
\end{minted}
Писать можно в любом текстовом редакторе, однако есть очень удобная вещь --- тетрадки jupyter
(New -> Python3, Ctrl + Enter, \mintinline{python}{%matplotlib inline}).
Также можно использовать alpha.iodide.io.

Python is powerful... and fast;
plays well with others;
runs everywhere;
is friendly \& easy to learn;
is Open.

Стековая машина, польская нотация и последовательность вычислений.

Минималистичный синтаксис, большой объём реализованных полезных функций.
Портирован на огромное число платформ и ОС. Гвидо
ван Россум, конец 80х.

Интерпретируемый язык с динамической типизацией.

Синтаксис: тип переменной не объявляется (иногда его можно явно объявить),
фигурных скобок нет, вместо них --- отступы. Посмотрим на его возможности с точки зрения того, что
мы знаем про C++ и стандартную библиотеку.

Пример программы на питоне, вычисляющей сумму чисел Фибоначчи.
\begin{minted}{python}
  # a comment
  import time # modules instead of libs

  def fib(n):
      if n == 0:
          return 0 # можно не ставить ;
      elif n == 1:
          return 1
      elif n>1:
          return fib(n - 1) + fib(n - 2)
      else: # n < 0
          return fib(n+2) - fib(n+1)

  start = time.clock() # access to a function from module
  n = 30
  sum = 0
  start = time.perf_counter()
  for i in range(n): # list(range(3)) = [0, 1, 2]
      sum += fib(i)
  end = time.perf_counter()
  print("sum = ", sum)
  print("uptime = " + str(end - start) + " s")
\end{minted}

Замечания.
\begin{minted}{python}
  5 / 2 # 2.5
  5 % 2 # 1
  2**2 # power
  5**2 # 25
  "Its ok" # string
  "It\"s ok" # the same
  print("1\n2")
  # 1
  # 2
  print(r"1\n2") # raw string
  # 1\n2
  print("""Hi! # string on multiple lines
  Bye!""")
  # Hi!
  # Bye!
  "Py" + "thon" # Python
\end{minted}

Индексы списка в питоне часто используются. Как реализовать списки? Списки на самом деле
разнородные в питоне.
\begin{minted}{python}
  word = "Jupite"r
  print(word[0], word[1], word[-1])
  # J u r
  print(word[7])
  # Index error
\end{minted}

Слайсы $a[:]$, отрицательные индексы и т. д. Пределы индексов.

Списки, продолжение.
\begin{minted}{python}
  x = [1,2] + [3, 4] # [1,2,3,4]
  x.append(5) # [1,2,3,4,5]
  x.append(x[-1]) # [...4,5,5]
  x[0:2] = [] # x = [3,4,5,5]
  len(x) = 4
  y = [[1,2],3]
  y[0][0] # 1
\end{minted}

List comprehension (абстракция списков, включение списков).
\begin{minted}{python}
  y = []
  for i in range(4):
      y.append(i * i)
  print(y) # 0,1,4,9
\end{minted}
Код эквивалентен следующему:
\begin{minted}{python}
  y = [i * i for i in range(4)]
\end{minted}
Возможно добавление условий:
\begin{minted}{python}
  # числа, не делящиеся на 3
  y = [i for i in range(30) if i % 3 != 0]
  # не делятся на 3, 2 и на 5
  x = [z for z in y if z % 5 != 0 and z % 2 !=0]
  # [1, 7, 11, ...]
  # пример посложнее
  from math import sin
  z = [sin(i/20) * sin(j/20) for i in range(100) for j in range(100)]
  len(z) # 10000
\end{minted}

Кортежи (Tuple). Разница с массивами - структура vs упорядоченность. Разный смысл. Постоянная
структура и длина, могут быть использованы в key - value.
\begin{minted}{python}
  u = (1, "a")
  u[0]
  u[1]
  u + ("qwe", "qwa") # (1, "a", "qwe", "qwa")
  u[0] = 2 # ERROR, item assignment in tuples is not allowed
  # --- tuples are immutable
  # list comprehenshion again
  [(x, y) for x in range(1,10) for y in range(1,10) if x % y != 0]
  # deletes 5-th element
  del a[5]
  # deletes entire variable
  del a
  # now a[0] = 5 is error
\end{minted}

Функции
\begin{minted}{python}
  def fib(n):
      """Print a Fibonacci series up to n."""
      a, b = 0, 1
      while a < n:
        print(a, end = " ")
        a, b = b, b + a
      print()
  # default arguments
  def hello(x, y = "Hello, ", z = "!"):
    print(y + x + z)
  hello("world") # Hello, world!
  hello("Mike", "Hi, ") # Hi, Mike!
  hello("world", z = "?") # Hello, world?
  # последнее удобнее, чем в C++
\end{minted}

Словари. Подобны типу map из стандартной библиотеки C++, key -- value хранилище (как оно может быть
устроено?).
\begin{minted}{python}
  tel = {"guido": 1234, "mike": 4690}
  print(tel["guido"]) # 1234
  tel["john"] = 4321
  del tel["guido"]
  [print(x) for x in tel] # "john", "mike"
  [print(tel[x]) for x in tel] # 4321, 4690
\end{minted}

Снова про функции.
\begin{minted}{python}
  def f(x, y, z = 4, a = 5):
      print(x, y, z, a)
  xy = [1, 2]
  f(*xy) # 1 2 4 5
  za = {"z": 72}
  f(9, 8, **za) # 9 8 72 5
  #
  import matplotlib.pyplot as mpl
  from math import *
  x = [0.1 * i for i in range(100)]
  y = [sin(z) for z in x]
  # keyword arguments
  kwargs = {"color": "r", "linewidth": 0.7}
  plot(x, y, **kwargs)
\end{minted}

\subsection{Matplotlib на примере Collatz conjecture, гипотеза Коллатца}

Рассмотрим функцию от натуральных чисел:
\begin{eqnarray}
    f(n) & = & n / 2, \text{ $n$ --- четное}, \\
    f(n) & = & 3 n + 1, \text{ в противном случае}.
\end{eqnarray}

Рассмотрим последовательность:
\begin{equation}
  n, f(n), f(f(n)), ...
\end{equation}

Гипотеза: для любого натурального $n$ последовательность придёт к единице.
Проверим гипотезу для небольших $n$ перебором. Будем рисовать то, что происходит с числами на
каждом шаге до тех пор, пока они не придут к единице.

\inputminted{python}{collatz.py}

\begin{figure}[p]
  \centering
  \includegraphics[width=8.3cm]{collatz.png}
  %\caption{\label{fig:collatz5}}
\end{figure}

\subsection{Numpy}

Рассмотрим пример цикла на питоне:
\begin{minted}{python}
  n = 10000
  a = []
  for i in range(n):
      a.append(sqrt(i / (n - 1))
\end{minted}
Что здесь может работать медленно?
\begin{enumerate}
    \item Цикл сам по себе работает не быстро из-за особенностей интерпретатора
        Python, и при простом содержимом цикла может быть гораздо затратнее
        содержимого.
    \item Вызов функции в питоне гораздо более затратен, чем в C++, частично
        из-за приведения типов и выбора из набора функций для разных типов.
        Рекурсии в питоне стоит также избегать.
\end{enumerate}

Варианты решения проблем: multiprocessing

JIT-компиляция. Pypy --- вместо интерпретатора питона,
делает байт-код, потом компилирует его с оптимозацией. Существенно (в разы)
ускорение, однако не поддерживает все библиотеки питона. Numba --- создаёт
скомпилированные версии функций, может быть применена только к части кода. Очень
новая, нет в репозиториях и т. п.

Другой вариант --- векторизация операций. Интерпретация кода происходит один
раз, например, в list comprehension.

Аналогичный подход --- в библиотеке numpy. Перепишем наш код:
\begin{minted}{python}
    import numpy as np
    n = 10000
    a = np.arange(n) # 0..(n-1)
    a = a * i / (n - 1)
    a = np.sqrt(a) # sqrt от каждого элемента.
\end{minted}
Всего 3 (а не 30000) вызова функции и решения о типе и т. д. Корень работает
быстро (используется ф-я на C, скорее всего). Подобная векторная идеология
интенсивно используется в языке R. Вообще, провалов производительности везде
можно избежать, и уменьшение скорости по сравнению с C++ может быть и не очень
большим (10 раз по сравнению с O3).

\begin{minted}{python}
    #numpy tutorial
    import numpy as np
    a = np.array([1, 2, 3, 4, 5, 6]) # array([[1,2],[3,4]])
    print(type(a)) # numpy.ndarray
    print(a.shape) # (6,)
    b = np.reshape(a, (2,3))
    # [[1,2,3],
    #  [4,5,6]]
    print(b[0,1]) # 2
    print(b.transpose())
    # create empty, with ones, random, zeros...
    np.empty((5, 4))
    ...zeros, ones...
    np.eye(3) # identity matrix
    np.random.random((2,2)) # uniform (linear distribution), [0, 1)
    np.random.random(5)
    # slices
    c = b[:,1:]
    print(c)
    # [[2, 3]
    #  [5, 6]]
    # bool indexing
    bi = (c%2 == 1)
    # [[False,  True],
    # [ True, False]], dtype=bool
    print(c[bi]) # [3, 5] # matrix as index,
                          # [i] ведут себя по-разному в зависимости от типа i
    c[c%2 == 1] # alternative
    c[c > 2] # [3, 5, 6]
    # data type
    x = np.array([1,2,3], dtype=np.float) # int, int64, float, float64...
    # math
    x = np.arange(100)
    x = 0.1 * x
    y = np.sin(x) + np.cos(x) # ...plot(x, y)
    y = x * y # поэлементно
    # matrix operations
    x = np.array([1,-1,2])
    y = np.array([3,5,7])
    np.dot(x,y) # 12, как скалярное произведение
    m = np.array([x1 * y1 for x1 in x for y1 in y])
    # [ 3,  5,  7, -3, -5, -7,  6, 10, 14], все со всеми
    m = np.reshape(m, (3, -1))
    # [[ 3,  5,  7],
    #  [-3, -5, -7],
    #  [ 6, 10, 14]]
    print(np.dot(m, x)) # [ 12, -12,  24]
    print(np.dot(x, m)) # [18, 30, 42]
\end{minted}


Рассмотрим
задачy: сгенерировать массив чисел наперёд заданной длины (!), числа псевдослучайные
с функцией распределения (вероятность найти число в интервале):
\begin{equation}
    f(x) = \frac{dw}{dx} \propto \exp(\sin(\pi x^2)),\; x \in (0, 1).
\end{equation}
и продемонстрировать корректность работы генератора.
\begin{enumerate}
  \item найти функцию распределания полученного генератора и сравнить с теорией
      на графике % 3 б
  \item найти и печатать на экран <<центр масс>> полученного
      распределения (среднее значение $x$), 0.561418%, 1 б
  \item для массива случайных точек из 10000 элементов измерить время генерации
      и нахождение среднего (суммарное), вывести на экран % 1 б за время, 1б за
      %хорошую скорость
\end{enumerate}

Решение. Числа будем генерировать, используя метод Монте-Карло на плоскости. Медленный метод:
\begin{minted}{python}
# -*- coding: utf-8 -*-

import time
import numpy as np

# число точек с нужным распределением
n = 200000

# функция распределения с максимумом, равным 1 при x \in (0, 1)
def f(x):
    return np.exp(np.sin(np.pi * x * x)) / np.e

def mean(x):
    return sum(x) / len(x)

rands = np.empty(n);

# slow generation
t0 = time.perf_counter()
i = 0
while i < n:
    r1 = np.random.rand()
    r2 = np.random.rand()
    if r2 < f(r1):
        rands[i] = r1
        i += 1

t1 = time.perf_counter()
print("slow generation took " + str(t1 - t0) + " s")
print("<x> = ", mean(rands)) # should be 0.561418
\end{minted}
На моём компьютере получается
\begin{minted}{bash}
    slow generation took 1.4595759409712628 s
    <x> =  0.561022241364
\end{minted}

Быстрый метод.
\begin{minted}{python}
# fast method of generation
t2 = time.perf_counter()
rands = np.array([])
m = n
while len(rands) < n:
    r1 = np.random.rand(m)
    r2 = np.random.rand(m)
    # list comprehension is fast, but to get huge speed-up we
    # also should compute f(r1) using vector operation
    r3 = f(r1)
    a = [x for ((x, y), z) in zip(zip(r1, r2), r3) if y < z]
    # ...but length(a) != n
    rands = np.append(rands, a)
    m = m - len(a) + 10000 # для простоты
rands = rands[:n] # обрезаем небольшой "хвост"
t3 = time.perf_counter()
print("fast generation took " + str(t3 - t2) + " s")
print("<x> = ", mean(rands))
\end{minted}
Получается:
\begin{minted}{bash}
    fast generation took 0.14974620402790606 s
    <x> =  0.561465849588
\end{minted}
Теперь нужно собрать числа по ведёркам.
\begin{minted}{python}
# распределяем по корзинкам (bins)
nb = 100
b = np.zeros(nb)
# медленный метод
t4 = time.perf_counter()
for x in rands:
    i = int(x * nb) # ok if x is always >=0 and < 1
    b[i] += 1
t5 = time.perf_counter()
print("slow buckets: " + str(t5 - t4) + " s")
# быстрый, "векторный" метод
t6 = time.perf_counter()
x = (rands * nb).astype(int) # element-wise to int
b = np.array([len(x[x==i]) for i in np.arange(nb)])
t7 = time.perf_counter()
print("fast buckets: " + str(t7 - t6) + " s")
# ещё один быстрый метод
t6 = time.perf_counter()
(b, bin_edges) = np.histogram(rands, nb, (0, 1))
t7 = time.perf_counter()
print("histogram: " + str(t7 - t6) + " s")
\end{minted}
Получилось:
\begin{minted}{bash}
    slow buckets: 0.26687249704264104 s
    fast buckets: 0.03806155297206715 s
    histogram:    0.004349093185737729 s
\end{minted}
Теперь построим ступеньками.
\begin{minted}{python}
# теперь построим
u = [[x, x] for x in b]
u = np.reshape(u, 2 * nb)
v = np.empty(2 * nb)
v[0] = bin_edges[0]
v[-1] = bin_edges[-1]
w = [[x, x] for x in bin_edges[1:-1]] # not includes the last
v[1:-1] = np.reshape(w, 2 * (nb - 1))
import matplotlib.pyplot as plt
plt.plot(v, u, "b-")
x = np.linspace(0, 1, 100)
plt.plot(x, f(x) * max(u), "r-")
plt.xlabel(r"$x$")
plt.ylabel(r"$f(x)$")
plt.show()
\end{minted}

%\begin{figure}
%  \centering
%  \includegraphics[width=8.3cm]{distribution_py.png}
%  \caption{Распределение сгенерированных чисел.}
%\end{figure}

\subsection{Matplotlib: настройки, gridspec}

\begin{minted}{python}
    import matplotlib
    import matplotlib.pyplot as plt
    from matplotlib import gridspec

    font = {"family" : "Liberation Serif",
            "weight" : "normal",
            "size"   : 10}
    matplotlib.rc("font", **font)
    matplotlib.rc("lines", linewidth=lw)
    matplotlib.rc("axes", linewidth=lw)

    plt.figure(figsize=(3.3,4.5),dpi=300) # in inches
    gs = gridspec.GridSpec(3, 2)
    gs.update(left=0.15, right=0.97, bottom=0.07, top=1.0, wspace = 0.55)
    plt.subplot( gs[0,:], aspect = T / 0.4 / 3 )
    plt.subplot( gs[1,:], aspect = T / 250 / 3 )
    plt.subplot( gs[2,1], aspect = 0.5 )
    plt.subplot( gs[2,0], aspect = a0[-1] - a0[0] )
    plt.savefig("qwe.pdf")
\end{minted}

\section{Что дальше?}

\subsection{Задача \# 5, множество Жулиа, 7 баллов}

Есть комплексное отображение:
\begin{equation}
    f(z) = z^2 - 0.4 + 0.6 i,
\end{equation}
И есть последовательность
\begin{equation}
    g(n) = f^n = f(f( ...)(z), \; n \text{ раз}.
\end{equation}
Задача: построить распределение $n: \; abs(g(n)(z)) <= 2$ в плоскости $z$ ($x \in
[-2,, 2]$, $y \in [-2, 2]$. Можно взять $400 \times 300$ точек, $150$ итераций.
\begin{enumerate}
\item 5 б. за график
\item 2 б. за палитру, красоту, подписи осей (tex), pdf, 12 см шириной.
\end{enumerate}

Замечания по задаче.
\begin{minted}{python}
z * z - 0.4 + 0.6j
plt.imshow(n - xys, origin = "lower", cmap = "cubehelix", interpolation = "none",
        extent = (x1, x2, y1, y2))
plt.clim(-n * 1 / 8, n)
plt.colorbar(label = r"$n$")
plt.xlabel(r"$\operatorname{Re} \, z$")
plt.ylabel(r"$\operatorname{Im} \, z$")
plt.tight_layout()
plt.savefig("julia.pdf")
\end{minted}

\subsection{FFI, scipy, ode, linalg...}

\subsection{Контрольная, 1 час, дома можно дорешать}

\newpage

\begin{enumerate}
    \item Составьте численную схему для решения уравнения
        \begin{equation}
            \frac{d^2 x}{dt^2} + \frac{dx}{dt} + x = 0.
        \end{equation}
    \item Дана группа --- множество чисел $\{1,2,..,p - 1\}$ с операцией умножения по модулю $p$,
        где $p$ --- простое число. Для $p = 7$ найдите (некоторые) подгруппы данной группы.
    \item Для интегрируемой функции $f$ найдите (с точностью до постоянного множителя) свёртку
        \begin{equation}
            g(x) = \int_{x - 1/2}^{x + 1/2} \int_{x_1 - 1/2}^{x_1 + 1/2} ... \int_{x_{n - 1} -
            1/2}^{x_{n - 1} + 1/2}
            f(x_n) \, dx_n \,
            ... \, dx_2 \, dx_1,
        \end{equation}
        где интегрирование производится $n$ раз, $n \gg 1$.
\end{enumerate}

\begin{enumerate}
    \item В равноудаленных точках численной сетки заданы числа $f_i$, $i \in \mathbb Z$.  На данной
        сетке можно ввести оператор трансляции, заменяющий числа $f_i$ на $f_{i - 1}$. Аналогичным
        образом оператор
        трансляции можно ввести для непрерывных функций. Найти генератор трансляции $\hat P$ для
        непрерывной функции $f(x)$, $x \in \mathbb R$ такой, что оператор трансляции на малое
        расстояние $a$ есть $\hat A f = f + a \hat P f$.
    \item Доказать, что если для любого элемента $a$ из некоторой группы выполнено условие $a \cdot
        a = e$, где $e$ --- единичный элемент, то для любых двух элементов группы $b$ и $c$
        выполнено равенство $bc = cb$. Приведите пример нетривиальной группы, для которой квадрат
        любого элемента равен единице.
    \item Для интегрируемой функции $f$ найдите (с точностью до постоянного множителя) свёртку
        \begin{multline}
            g(x) = \int_{-\infty}^\infty \int_{-\infty}^\infty ... \int_{-\infty}^\infty
            f(x_n) \exp\left[-(x_n - x_{n - 1})^2 \right] ...\\
            \exp\left[-(x_2 - x_1)^2 \right]
            \exp\left[-(x_1 - x)^2 \right]
            \, dx_n \, ... \, dx_2 \, dx_1,
        \end{multline}
        где интегрирование производится $n$ раз, $n \gg 1$.
\end{enumerate}

\begin{enumerate}
    \item Найти предел последовательности $a_i$ при $i \to \infty$, если $a_0 = 2$, а $a_{i + 1} =
        (a_i + 5 / a_i) / 2$.
    \item Дано множество чисел $\{1,2,..,p - 1\}$ с операцией умножения по модулю $p$.
        Для $p = 6$ найдите подмножества данного множества, образующие группы с данной групповой
        операцией.
    \item  Пусть $A$ и $B$ --- квадратные матрицы $n \times n$ ($n \gg 1$),
        коэффициенты которых --- независимые случайные числа с равномерным распределением на
        отрезке $[0, 1]$. Оцените среднее и дисперсию элементов матрицы --- произведения $A B$.
        Предложите метод для оценки среднего и дисперсии детерминанта матрицы $A$.
\end{enumerate}

\newpage

\section{Функциональное программирование. Why FP matters}

Функция высшего порядка --- функция, принимающая и (или) возвращающая другую функцию.

Зачем нужно оперировать функциями? Например, есть список
\begin{minted}{cpp}
    class mylist {
        mylist* next;
        double value;
    };
\end{minted}
Для double у нас есть много функций (sin, sqrt, арифметика, round, int). Хочется их всех применять
поэлементно для списка (можно реализовать шаблон с передачей функции или указателя на йункцию в
качестве аргумента).

Другой пример: пишем <<решатель>> уравнений движения частицы в произвольных электромагнитных полях.
Решатель принимает указатель на функцию двух аргументов ($\mathbf r$ и $t$), а поля удобно задавать
функциями со своими параметрами:
\begin{minted}{cpp}
    field plane_wave(vec r, double t, double a0, double phi)
    // ...
    field const_B(double a0)
    // ...
\end{minted}
Как их превратать в функцию двух аргументов? (частично применённые функции).

Зачем это может быть использовано?

Как и в структурном программировании, важна модульность. Небольшие простые модули проще пишутся,
легче отлаживаются (причём по отдельности). Модули общего назначения могут быть переиспользованы. 

Рассмотрим примеры.

(John Hughes, Why functional programming matters, 1990).

Haskell. Декларативный стиль, неизменяемые переменные, частичное применение функций, рекурсия
(оптимизация хвостовой рекурсии) вместо циклов, отложенные вычисления, вывод типов.

Решим задачу о генерации ровно $n$ псевдослучайных чисел со сложным распределением. Для этого
воспользуемся списками.

\begin{minted}{haskell}
-- список - либо пустой, либо сделанный конструктором
-- из элемента и "хвоста" (тоже списка)
data List a = Cons a (List a) | Nil
    deriving Show

-- алгебраические типы данных, в Rust - enum...
-- Как они могут быть устроены?
-- Др. пример: Option a = Sone a | None

-- определим сумму
sum Nil = 0
sum (Cons x xs) = x + sum_ xs

-- 0 и + определяют сумму; обобщим:
-- (...x + (y + (z + 0)))
-- 0 -> x, + -> f, скобки у функций не пишутся
foldr_ f x Nil = x
foldr_ f x (Cons y ys) = f y (foldr_ f x ys)
-- разобрать пример у доски?

-- sum -> foldr (+) 0
sum_ = foldr_ (+) 0
product = foldr_ (*) 1
-- anytrue, alltrue...

-- Можно заметить, что (foldr f x) заменяет в списке
-- все Cons на f а Nil на x.
-- Cons 3 (Cons 4 (Cons 5 Nil) -> (+) 3 ((+) 4 ((+) 5 0)) = 12

-- тогда (foldr Cons Nil) просто копирует список!

-- Склеим два списка
append a b = foldr_ Cons b a

-- Измерим длину списка
length_ as = foldr_ count 0 as
-- типы a и n совершенно разные!
count a n = n + 1

-- Ещё нам понадобатся функция, применяющая некоторую функцию _g_
-- к каждому элементу списка. Для этого Cons надо заменить на композицию
-- (cons . g), а Nil на Nil.
map_ f a = foldr_ (\x y -> Cons (f x) y) Nil a

-- Таким образом, из одной небольшой функции foldr получили
-- и map, и length, и sum и т. д.

-- Можно по-другому:
map__ _ Nil = Nil
map__ g (Cons x xs) = Cons (g x) (map__ g xs)
\end{minted}

Программы в функиональной парадигме --- функции из начального состояния в конечное. Композиция $f
\circ g, \; (f \circ g)(x) = f(g(x))$ --- композиция программ. Такая композиция может быть
организована через сохранение промежуточных результатов в файле. Однако файл может оказаться
слишком большим и, главное, условие окончания работы известно в программе f, а не в g, что мешает
композиции. Идея отложенных вычислений (lazy evaluation): функция g даёт результат по мере того,
как он требуется функции f. Могут ли отложенные вычисления ужиться с функциями с побочными
эффектами?

\subsection{FP in C++ and Python}

\inputminted{cpp}{whyfpmatters.cpp}

Отложенные вычисления --- пример с пересечениями фигур.

map, reduce

\subsection{ООП в Erlang}

habr

\subsection{Maxwell, dispersion relation}

see Dropbox - prog (связанные осцилляторы)

\subsection{Theorem for free}

habr, аналитическое вычисление производных

constexpr?
shared ptr?
понятие о DSL

\bibliographystyle{unsrt}
\bibliography{lectures}

\end{document}
